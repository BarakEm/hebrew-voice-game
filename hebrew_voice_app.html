<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#f0f8ff">
    <title>Hebrew Voice Game</title>
    
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            padding: 4vmin;
            gap: 3vmin;
        }

        /* Mode Selection Screen */
        .mode-screen {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .mode-title {
            text-align: center;
            font-size: clamp(24px, 8vmin, 60px);
            font-weight: bold;
            color: #6495ed;
            padding: 2vmin 0;
        }

        .mode-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }

        .mode-button {
            flex: 1;
            border: none;
            border-radius: 30px;
            font-size: clamp(18px, 5vmin, 40px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 6px 6px 0 rgba(100, 100, 100, 0.4);
            border: 4px solid white;
            transition: transform 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1vmin;
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button .icon {
            font-size: clamp(30px, 10vmin, 80px);
        }

        .mode-button.free-speech { background-color: #32cd32; }
        .mode-button.spelling { background-color: #ff6b6b; }
        .mode-button.translation { background-color: #4ecdc4; }
        .mode-button.disabled {
            background-color: #ccc;
            opacity: 0.6;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .game-screen.active {
            display: flex;
        }

        .mode-screen.hidden {
            display: none;
        }

        /* Top bar with back button and language toggle */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2vmin;
        }

        .back-button {
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 15px;
            padding: 2vmin 4vmin;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 rgba(100, 100, 100, 0.3);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .lang-toggle {
            display: flex;
            background: white;
            border-radius: 25px;
            padding: 0.5vmin;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .lang-btn {
            padding: 2vmin 4vmin;
            border: none;
            border-radius: 20px;
            font-size: clamp(14px, 3.5vmin, 24px);
            font-weight: bold;
            cursor: pointer;
            background: transparent;
            color: #666;
            transition: all 0.2s ease;
        }

        .lang-btn.active {
            background: #6495ed;
            color: white;
        }

        /* Continuous mode button */
        .continuous-btn {
            background: transparent;
            border: 3px solid #9b59b6;
            color: #9b59b6;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(18px, 4vmin, 28px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .continuous-btn.active {
            background: #9b59b6;
            color: white;
            animation: continuousPulse 1s ease-in-out infinite;
        }

        @keyframes continuousPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 15px 5px rgba(155, 89, 182, 0.3); }
        }

        /* Cast button */
        google-cast-launcher {
            display: inline-block;
            flex-shrink: 0;
            --connected-color: #32cd32;
            --disconnected-color: #6495ed;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            cursor: pointer;
        }

        /* Display area */
        .display-area {
            flex: 1;
            background: white;
            border-radius: 30px;
            border: 5px solid #6495ed;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 0;
        }

        .display-text {
            font-size: clamp(24px, 12vmin, 120px);
            font-weight: bold;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .text-blue { color: #6495ed; }
        .text-red { color: #ff5050; }
        .text-yellow { color: #daa520; }
        .text-black { color: #000; }
        .text-green { color: #32cd32; }

        /* Button area */
        .button-area {
            height: 22vh;
            min-height: 80px;
        }

        .big-button {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 40px;
            font-size: clamp(20px, 6vmin, 48px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            outline: none;
            transition: transform 0.1s ease;
            box-shadow: 8px 8px 0 rgba(100, 100, 100, 0.5);
            border: 6px solid white;
        }

        .big-button:active {
            transform: scale(0.98);
        }

        .button-ready { background-color: #32cd32; }
        .button-recording {
            background-color: #ff5050;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        .button-processing {
            background-color: #ffd700;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.03); }
        }

        /* Error banner */
        .error-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff5050;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 18px;
            display: none;
            z-index: 100;
        }

        .error-banner.show {
            display: block;
        }

        /* Speaker button for TTS */
        .speaker-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(20px, 5vmin, 36px);
            cursor: pointer;
            display: none;
        }

        .speaker-btn.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .display-area {
            position: relative;
        }
    </style>
</head>
<body>
    <div id="errorBanner" class="error-banner"></div>

    <!-- Mode Selection Screen -->
    <div id="modeScreen" class="mode-screen">
        <div class="mode-title" id="modeTitle">◊ë◊ó◊® ◊û◊©◊ó◊ß</div>
        <div class="mode-buttons">
            <button class="mode-button free-speech" onclick="startMode('free-speech')">
                <span class="icon">üé§</span>
                <span id="freeSpeechLabel">◊ì◊ô◊ë◊ï◊® ◊ó◊ï◊§◊©◊ô</span>
            </button>
            <button class="mode-button spelling" onclick="startMode('spelling')">
                <span class="icon">üìù</span>
                <span id="spellingLabel">◊ê◊ô◊ï◊™</span>
            </button>
            <button class="mode-button translation" onclick="startMode('translation')">
                <span class="icon">üåç</span>
                <span id="translationLabel">◊™◊®◊í◊ï◊ù</span>
            </button>
        </div>
    </div>

    <!-- Free Speech Game Screen -->
    <div id="gameScreen" class="game-screen">
        <div class="top-bar">
            <button class="back-button" onclick="goBack()">‚Üê ◊ó◊ñ◊®◊î</button>
            <button class="continuous-btn" id="continuousBtn" onclick="toggleContinuous()">‚àû</button>
            <google-cast-launcher id="castButton"></google-cast-launcher>
            <span id="castStatus" style="display: none; font-size: 12px; color: #999;"></span>
            <div class="lang-toggle">
                <button class="lang-btn active" id="btnHebrew" onclick="setLanguage('hebrew')">◊¢◊ë◊®◊ô◊™</button>
                <button class="lang-btn" id="btnEnglish" onclick="setLanguage('english')">English</button>
            </div>
        </div>

        <div class="display-area">
            <button id="speakerBtn" class="speaker-btn" onclick="handleSpeakerClick()">üîä</button>
            <div id="displayText" class="display-text text-blue">◊ê◊û◊ï◊® ◊û◊©◊î◊ï ◊ë◊¢◊ë◊®◊ô◊™!</div>
        </div>

        <div class="button-area">
            <button id="mainButton" class="big-button button-ready">◊ú◊ó◊• ◊ú◊ì◊ë◊®!</button>
        </div>
    </div>

    <script>
        // ===========================================
        // GOOGLE CAST INITIALIZATION
        // ===========================================
        
        // Track if Cast API callback was called
        let castApiCallbackReceived = false;
        
        window['__onGCastApiAvailable'] = function(isAvailable) {
            castApiCallbackReceived = true;
            console.log('‚úÖ Google Cast API callback received');
            console.log('Google Cast API availability:', isAvailable);
            
            const statusEl = document.getElementById('castStatus');
            
            if (isAvailable) {
                initializeCastApi();
                if (statusEl) {
                    statusEl.textContent = '‚úì Cast ready';
                    statusEl.style.display = 'inline';
                    statusEl.style.color = '#32cd32';
                    statusEl.title = 'Cast is ready. Click the cast button to connect.';
                    // Hide after 3 seconds
                    setTimeout(() => statusEl.style.display = 'none', 3000);
                }
            } else {
                console.warn('‚ö†Ô∏è Google Cast API not available');
                console.warn('Please use Chrome browser for Cast support');
                if (statusEl) {
                    statusEl.textContent = '‚ö†Ô∏è Use Chrome';
                    statusEl.style.display = 'inline';
                    statusEl.style.color = '#ffa500';
                    statusEl.title = 'Cast requires Chrome browser';
                }
            }
        };
        
        // Check if callback was called after a timeout
        setTimeout(function() {
            if (!castApiCallbackReceived) {
                console.error('‚ùå Google Cast API callback was NEVER called');
                console.error('This usually means:');
                console.error('  1. Cast SDK script failed to load');
                console.error('  2. Network/CORS issue blocking the script');
                console.error('  3. Script loaded but callback timing issue');
                console.log('Cast SDK script URL: https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1');
                
                // Show user-friendly status
                const statusEl = document.getElementById('castStatus');
                if (statusEl) {
                    statusEl.textContent = '‚ö†Ô∏è Cast unavailable';
                    statusEl.style.display = 'inline';
                    statusEl.title = 'Cast API did not load. Use Chrome browser on same WiFi as Chromecast.';
                }
            }
        }, 5000);

        function initializeCastApi() {
            try {
                const castContext = cast.framework.CastContext.getInstance();
                
                // Configure Cast options
                castContext.setOptions({
                    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });
                
                // Listen for cast state changes
                castContext.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    onCastStateChanged
                );
                
                // Check initial state
                const castState = castContext.getCastState();
                console.log('Google Cast initialized. Initial state:', castState);
                handleCastState(castState);
            } catch (error) {
                console.error('‚ùå Failed to initialize Cast API:', error);
                console.error('Error details:', error.message);
            }
        }

        function onCastStateChanged(event) {
            console.log('Cast state changed:', event.castState);
            handleCastState(event.castState);
        }

        function handleCastState(castState) {
            const statusEl = document.getElementById('castStatus');
            
            switch (castState) {
                case cast.framework.CastState.CONNECTED:
                    console.log('‚úÖ Connected to TV!');
                    optimizeForTV();
                    if (statusEl) {
                        statusEl.textContent = 'üì∫ Connected';
                        statusEl.style.display = 'inline';
                        statusEl.style.color = '#32cd32';
                        statusEl.title = 'Connected to TV';
                    }
                    break;
                case cast.framework.CastState.CONNECTING:
                    console.log('üîÑ Connecting to TV...');
                    if (statusEl) {
                        statusEl.textContent = 'üîÑ Connecting...';
                        statusEl.style.display = 'inline';
                        statusEl.style.color = '#ffa500';
                        statusEl.title = 'Connecting to TV';
                    }
                    break;
                case cast.framework.CastState.NOT_CONNECTED:
                    console.log('üì∫ Disconnected from TV');
                    resetTVOptimization();
                    if (statusEl) {
                        // Hide status when not connected (cast button is enough indicator)
                        statusEl.style.display = 'none';
                    }
                    break;
                case cast.framework.CastState.NO_DEVICES_AVAILABLE:
                    console.log('‚ùå No Chromecast devices found on network');
                    console.log('üí° Make sure your Chromecast/Google TV is:');
                    console.log('   - Powered on and connected to the same WiFi network');
                    console.log('   - Visible in Google Home app');
                    if (statusEl) {
                        statusEl.textContent = '‚ö†Ô∏è No devices';
                        statusEl.style.display = 'inline';
                        statusEl.style.color = '#ff5050';
                        statusEl.title = 'No Chromecast found. Check WiFi and device.';
                    }
                    break;
            }
        }

        function optimizeForTV() {
            // Make content larger for TV viewing
            document.documentElement.style.fontSize = '120%';
            console.log('Optimized for TV display');
        }

        function resetTVOptimization() {
            // Reset to normal size
            document.documentElement.style.fontSize = '100%';
            console.log('Reset to normal display');
        }

        // ===========================================
        // LETTER NAMES FOR SPELLING
        // ===========================================
        const HEBREW_LETTER_NAMES = {
            '◊ê': '◊ê÷∏◊ú÷∂◊£', '◊ë': '◊ë÷µ÷º◊ô◊™', '◊í': '◊í÷¥÷º◊ô◊û÷∂◊ú', '◊ì': '◊ì÷∏÷º◊ú÷∂◊™', '◊î': '◊î÷µ◊ê',
            '◊ï': '◊ï÷∏◊ï', '◊ñ': '◊ñ÷∑◊ô÷¥◊ü', '◊ó': '◊ó÷µ◊ô◊™', '◊ò': '◊ò÷µ◊ô◊™', '◊ô': '◊ô◊ï÷π◊ì',
            '◊õ': '◊õ÷∏÷º◊£', '◊ö': '◊õ÷∏÷º◊£ ◊°◊ï÷π◊§÷¥◊ô◊™', '◊ú': '◊ú÷∏◊û÷∂◊ì', '◊û': '◊û÷µ◊ù', '◊ù': '◊û÷µ◊ù ◊°◊ï÷π◊§÷¥◊ô◊™',
            '◊†': '◊†◊ï÷º◊ü', '◊ü': '◊†◊ï÷º◊ü ◊°◊ï÷π◊§÷¥◊ô◊™', '◊°': '◊°÷∏◊û÷∂◊ö', '◊¢': '◊¢÷∑◊ô÷¥◊ü', '◊§': '◊§÷µ÷º◊ê',
            '◊£': '◊§÷µ÷º◊ê ◊°◊ï÷π◊§÷¥◊ô◊™', '◊¶': '◊¶÷∏◊ì÷¥◊ô', '◊•': '◊¶÷∏◊ì÷¥◊ô ◊°◊ï÷π◊§÷¥◊ô◊™', '◊ß': '◊ß◊ï÷π◊£',
            '◊®': '◊®÷µ◊ô◊©◊Å', '◊©': '◊©÷¥◊Å◊ô◊ü', '◊™': '◊™÷∏÷º◊ï'
        };

        // ===========================================
        // LANGUAGE CONFIGURATION
        // ===========================================
        const LANGUAGES = {
            hebrew: {
                code: 'he-IL',
                dir: 'rtl',
                text: {
                    SELECT_MODE: '◊ë◊ó◊® ◊û◊©◊ó◊ß',
                    FREE_SPEECH: '◊ì◊ô◊ë◊ï◊® ◊ó◊ï◊§◊©◊ô',
                    SPELLING: '◊ê◊ô◊ï◊™',
                    TRANSLATION: '◊™◊®◊í◊ï◊ù',
                    TRANSLATING: '◊û◊™◊®◊í◊ù...',
                    TRANSLATE_TO: '◊ê◊û◊ï◊® ◊û◊©◊î◊ï ◊ë◊¢◊ë◊®◊ô◊™ ◊ú◊™◊®◊í◊ï◊ù ◊ú◊ê◊†◊í◊ú◊ô◊™',
                    TRANSLATION_ERROR: '◊©◊í◊ô◊ê◊™ ◊™◊®◊í◊ï◊ù',
                    BACK: '‚Üê ◊ó◊ñ◊®◊î',
                    TAP_TO_SPEAK: '◊ú◊ó◊• ◊ú◊ì◊ë◊®!',
                    RECORDING: '◊û◊ß◊ú◊ô◊ò... (◊ú◊ó◊• ◊ú◊¢◊¶◊ô◊®◊î)',
                    PROCESSING: '◊û◊¢◊ë◊ì...',
                    LISTENING: '◊û◊ß◊©◊ô◊ë...',
                    THINKING: '◊ó◊ï◊©◊ë...',
                    SAY_SOMETHING: '◊ê◊û◊ï◊® ◊û◊©◊î◊ï ◊ë◊¢◊ë◊®◊ô◊™!',
                    NOT_UNDERSTOOD: '◊ú◊ê ◊î◊ë◊†◊™◊ô',
                    NETWORK_ERROR: '◊©◊í◊ô◊ê◊™ ◊®◊©◊™',
                    NOT_SUPPORTED: '◊î◊ì◊§◊ì◊§◊ü ◊ú◊ê ◊™◊ï◊û◊ö ◊ë◊ñ◊ô◊î◊ï◊ô ◊ß◊ï◊ú',
                    NEED_PERMISSION: '◊†◊ì◊®◊©◊™ ◊î◊®◊©◊ê◊™ ◊û◊ô◊ß◊®◊ï◊§◊ï◊ü',
                    CONTINUOUS: '◊®◊¶◊£',
                    CONTINUOUS_ON: '◊®◊¶◊£ ◊§◊¢◊ô◊ú'
                }
            },
            english: {
                code: 'en-US',
                dir: 'ltr',
                text: {
                    SELECT_MODE: 'Select Game',
                    FREE_SPEECH: 'Free Speech',
                    SPELLING: 'Spelling',
                    TRANSLATION: 'Translation',
                    TRANSLATING: 'Translating...',
                    TRANSLATE_TO: 'Say something in English to translate to Hebrew',
                    TRANSLATION_ERROR: 'Translation error',
                    BACK: '‚Üê Back',
                    TAP_TO_SPEAK: 'Tap to Speak!',
                    RECORDING: 'Recording... (tap to stop)',
                    PROCESSING: 'Processing...',
                    LISTENING: 'Listening...',
                    THINKING: 'Thinking...',
                    SAY_SOMETHING: 'Say something in English!',
                    NOT_UNDERSTOOD: "Didn't understand",
                    NETWORK_ERROR: 'Network error',
                    NOT_SUPPORTED: 'Browser does not support speech recognition',
                    NEED_PERMISSION: 'Microphone permission required',
                    CONTINUOUS: 'Loop',
                    CONTINUOUS_ON: 'Loop Active'
                }
            }
        };

        // ===========================================
        // STATE
        // ===========================================
        let currentLang = 'hebrew';
        let currentMode = null;
        let state = 'ready';
        let recognition = null;
        let recordingTimeout = null;
        let isRecognitionActive = false;
        let lastRecognizedText = '';
        let continuousMode = false;

        const MAX_RECORDING_TIME = 10000;

        // ===========================================
        // ELEMENTS
        // ===========================================
        const modeScreen = document.getElementById('modeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const modeTitle = document.getElementById('modeTitle');
        const freeSpeechLabel = document.getElementById('freeSpeechLabel');
        const spellingLabel = document.getElementById('spellingLabel');
        const translationLabel = document.getElementById('translationLabel');
        const displayText = document.getElementById('displayText');
        const mainButton = document.getElementById('mainButton');
        const errorBanner = document.getElementById('errorBanner');
        const btnHebrew = document.getElementById('btnHebrew');
        const btnEnglish = document.getElementById('btnEnglish');
        const speakerBtn = document.getElementById('speakerBtn');
        const backButton = document.querySelector('.back-button');
        const continuousBtn = document.getElementById('continuousBtn');

        // ===========================================
        // TEXT-TO-SPEECH
        // ===========================================
        const synth = window.speechSynthesis;

        function speakText(text = null, onComplete = null) {
            const textToSpeak = text || lastRecognizedText;
            if (!textToSpeak || !synth) {
                if (onComplete) onComplete();
                return;
            }

            synth.cancel();
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = LANGUAGES[currentLang].code;
            utterance.rate = 0.8;

            utterance.onend = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            utterance.onerror = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            synth.speak(utterance);
        }

        // Handle speaker button click - speaks in correct language based on mode
        function handleSpeakerClick() {
            if (!lastRecognizedText) return;

            if (currentMode === 'translation') {
                // In translation mode, lastRecognizedText is in the TARGET language
                const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';
                speakInLanguage(lastRecognizedText, targetLangCode);
            } else {
                speakText();
            }
        }

        // Speak and spell: say each word then spell it letter by letter
        function speakAndSpell(text) {
            if (!text || !synth) {
                if (continuousMode) restartListeningAfterDelay();
                return;
            }

            synth.cancel();
            const words = text.split(/\s+/).filter(w => w.length > 0);
            const langCode = LANGUAGES[currentLang].code;
            const isHebrew = currentLang === 'hebrew';

            let lastUtterance = null;

            // Queue all utterances
            words.forEach((word, wordIndex) => {
                // Say the whole word first
                const wordUtterance = new SpeechSynthesisUtterance(word);
                wordUtterance.lang = langCode;
                wordUtterance.rate = 0.8;
                synth.speak(wordUtterance);
                lastUtterance = wordUtterance;

                // Then spell each letter
                const letters = [...word];
                letters.forEach((letter, letterIndex) => {
                    let letterName;
                    if (isHebrew && HEBREW_LETTER_NAMES[letter]) {
                        letterName = HEBREW_LETTER_NAMES[letter];
                    } else {
                        // For English or unknown characters, just say the letter
                        letterName = letter.toUpperCase();
                    }

                    const letterUtterance = new SpeechSynthesisUtterance(letterName);
                    letterUtterance.lang = langCode;
                    letterUtterance.rate = 0.7;
                    synth.speak(letterUtterance);
                    lastUtterance = letterUtterance;
                });

                // Add a pause between words (using a silent utterance or short pause word)
                if (wordIndex < words.length - 1) {
                    const pauseUtterance = new SpeechSynthesisUtterance('.');
                    pauseUtterance.lang = langCode;
                    pauseUtterance.rate = 0.3;
                    pauseUtterance.volume = 0;
                    synth.speak(pauseUtterance);
                    lastUtterance = pauseUtterance;
                }
            });

            // Restart listening after spelling completes in continuous mode
            if (lastUtterance && continuousMode) {
                lastUtterance.onend = () => {
                    restartListeningAfterDelay();
                };
                lastUtterance.onerror = () => {
                    restartListeningAfterDelay();
                };
            }
        }

        // ===========================================
        // TRANSLATION API
        // ===========================================
        async function translateText(text, fromLang, toLang) {
            // Use MyMemory free translation API
            const langPair = `${fromLang}|${toLang}`;
            const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${langPair}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.responseStatus === 200 && data.responseData) {
                    return data.responseData.translatedText;
                } else {
                    console.error('Translation API error:', data);
                    return null;
                }
            } catch (error) {
                console.error('Translation fetch error:', error);
                return null;
            }
        }

        // Speak text in a specific language (not necessarily current language)
        function speakInLanguage(text, langCode, onComplete = null) {
            if (!text || !synth) {
                if (onComplete) onComplete();
                return;
            }

            synth.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.8;

            utterance.onend = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            utterance.onerror = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            synth.speak(utterance);
        }

        // ===========================================
        // CONTINUOUS MODE
        // ===========================================
        function toggleContinuous() {
            continuousMode = !continuousMode;
            updateContinuousUI();
            console.log('Continuous mode:', continuousMode);

            if (continuousMode && (state === 'ready' || state === 'showing')) {
                // Start listening immediately when enabling continuous mode
                startRecording();
            } else if (!continuousMode && isRecognitionActive) {
                // Stop if we're currently recording
                stopRecording();
            }
        }

        function updateContinuousUI() {
            if (continuousMode) {
                continuousBtn.classList.add('active');
                continuousBtn.title = getText('CONTINUOUS_ON');
            } else {
                continuousBtn.classList.remove('active');
                continuousBtn.title = getText('CONTINUOUS');
            }
        }

        function restartListeningAfterDelay(delay = 500) {
            if (continuousMode && !isRecognitionActive) {
                setTimeout(() => {
                    if (continuousMode && (state === 'ready' || state === 'showing')) {
                        console.log('Continuous mode: restarting listening');
                        startRecording();
                    }
                }, delay);
            }
        }

        // ===========================================
        // LANGUAGE FUNCTIONS
        // ===========================================
        function getText(key) {
            return LANGUAGES[currentLang].text[key];
        }

        function setLanguage(lang) {
            currentLang = lang;
            const langConfig = LANGUAGES[lang];

            // Update document direction
            document.documentElement.lang = lang === 'hebrew' ? 'he' : 'en';
            document.documentElement.dir = langConfig.dir;

            // Update toggle buttons
            btnHebrew.classList.toggle('active', lang === 'hebrew');
            btnEnglish.classList.toggle('active', lang === 'english');

            // Update UI text
            updateUIText();

            // Reinitialize speech recognition with new language
            initSpeechRecognition();

            // Reset state
            if (state !== 'ready') {
                stopRecording();
            }
            setState('ready');
        }

        function updateUIText() {
            // Mode screen
            modeTitle.textContent = getText('SELECT_MODE');
            freeSpeechLabel.textContent = getText('FREE_SPEECH');
            spellingLabel.textContent = getText('SPELLING');
            translationLabel.textContent = getText('TRANSLATION');

            // Game screen
            backButton.textContent = getText('BACK');

            // Update based on current state
            if (state === 'ready') {
                if (currentMode === 'translation') {
                    displayText.textContent = getText('TRANSLATE_TO');
                } else {
                    displayText.textContent = getText('SAY_SOMETHING');
                }
                mainButton.textContent = getText('TAP_TO_SPEAK');
            }
        }

        // ===========================================
        // MODE NAVIGATION
        // ===========================================
        function startMode(mode) {
            currentMode = mode;
            modeScreen.classList.add('hidden');
            gameScreen.classList.add('active');
            setState('ready');
        }

        function goBack() {
            if (isRecognitionActive) {
                stopRecording();
            }
            // Disable continuous mode when going back
            continuousMode = false;
            updateContinuousUI();

            currentMode = null;
            lastRecognizedText = '';
            speakerBtn.classList.remove('visible');
            gameScreen.classList.remove('active');
            modeScreen.classList.remove('hidden');
        }

        // ===========================================
        // SPEECH RECOGNITION
        // ===========================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        function initSpeechRecognition() {
            if (!SpeechRecognition) {
                showError(getText('NOT_SUPPORTED') + ' - Use Chrome');
                return;
            }

            // Stop existing recognition
            if (recognition) {
                try {
                    recognition.abort();
                } catch (e) {}
            }

            recognition = new SpeechRecognition();
            recognition.lang = LANGUAGES[currentLang].code;
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log('Recognition started');
                isRecognitionActive = true;
                setState('recording');

                recordingTimeout = setTimeout(() => {
                    console.log('Auto-stopping after timeout');
                    stopRecording();
                }, MAX_RECORDING_TIME);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    console.log('Final:', finalTranscript);
                    clearRecordingTimeout();
                    showResult(finalTranscript);
                } else if (interimTranscript) {
                    console.log('Interim:', interimTranscript);
                    displayText.textContent = interimTranscript;
                    displayText.className = 'display-text text-black';
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                clearRecordingTimeout();
                isRecognitionActive = false;

                switch (event.error) {
                    case 'not-allowed':
                        showError(getText('NEED_PERMISSION'));
                        showResult(getText('NEED_PERMISSION'));
                        break;
                    case 'network':
                        showResult(getText('NETWORK_ERROR'));
                        break;
                    case 'no-speech':
                        showResult(getText('NOT_UNDERSTOOD'));
                        break;
                    case 'aborted':
                        setState('ready');
                        break;
                    default:
                        showResult(getText('NOT_UNDERSTOOD'));
                }
            };

            recognition.onend = () => {
                console.log('Recognition ended');
                clearRecordingTimeout();
                isRecognitionActive = false;

                if (state === 'recording') {
                    showResult(getText('NOT_UNDERSTOOD'));
                }
            };
        }

        function clearRecordingTimeout() {
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
        }

        // ===========================================
        // STATE MANAGEMENT
        // ===========================================
        function setState(newState) {
            state = newState;

            switch (state) {
                case 'ready':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    // Show appropriate prompt based on mode
                    if (currentMode === 'translation') {
                        displayText.textContent = getText('TRANSLATE_TO');
                    } else {
                        displayText.textContent = getText('SAY_SOMETHING');
                    }
                    displayText.className = 'display-text text-blue';
                    break;

                case 'recording':
                    mainButton.textContent = getText('RECORDING');
                    mainButton.className = 'big-button button-recording';
                    displayText.textContent = getText('LISTENING');
                    displayText.className = 'display-text text-red';
                    speakerBtn.classList.remove('visible');
                    break;

                case 'processing':
                    mainButton.textContent = getText('PROCESSING');
                    mainButton.className = 'big-button button-processing';
                    displayText.textContent = getText('THINKING');
                    displayText.className = 'display-text text-yellow';
                    break;

                case 'showing':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    break;
            }
        }

        function showResult(text) {
            const isError = text === getText('NOT_UNDERSTOOD') ||
                           text === getText('NETWORK_ERROR') ||
                           text === getText('NEED_PERMISSION');

            // Handle translation mode separately
            if (currentMode === 'translation' && !isError) {
                handleTranslationResult(text);
                return;
            }

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';
            displayText.textContent = text;
            displayText.className = 'display-text text-black';

            // Store for TTS and show speaker button
            if (!isError) {
                lastRecognizedText = text;
                speakerBtn.classList.add('visible');

                // In spelling mode, automatically speak and spell
                if (currentMode === 'spelling') {
                    setTimeout(() => speakAndSpell(text), 300);
                } else if (continuousMode) {
                    // In free speech continuous mode, speak the result then restart
                    setTimeout(() => speakText(text), 300);
                }
            } else {
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');

                // In continuous mode, keep listening even on errors
                if (continuousMode) {
                    restartListeningAfterDelay(1000);
                }
            }
        }

        async function handleTranslationResult(spokenText) {
            // Show translating state
            state = 'processing';
            mainButton.textContent = getText('PROCESSING');
            mainButton.className = 'big-button button-processing';
            displayText.textContent = getText('TRANSLATING');
            displayText.className = 'display-text text-yellow';

            // Determine source and target languages
            const fromLang = currentLang === 'hebrew' ? 'he' : 'en';
            const toLang = currentLang === 'hebrew' ? 'en' : 'he';
            const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';

            // Translate
            const translation = await translateText(spokenText, fromLang, toLang);

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';

            if (translation) {
                // Show both original and translation
                displayText.innerHTML = `<div style="font-size: 0.5em; color: #888; margin-bottom: 10px;">${spokenText}</div>${translation}`;
                displayText.className = 'display-text text-black';
                lastRecognizedText = translation;
                speakerBtn.classList.add('visible');

                // Speak the translation in target language
                setTimeout(() => {
                    speakInLanguage(translation, targetLangCode, continuousMode ? () => restartListeningAfterDelay() : null);
                }, 300);
            } else {
                displayText.textContent = getText('TRANSLATION_ERROR');
                displayText.className = 'display-text text-red';
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');

                if (continuousMode) {
                    restartListeningAfterDelay(1000);
                }
            }
        }

        function showError(message) {
            errorBanner.textContent = message;
            errorBanner.classList.add('show');
            setTimeout(() => {
                errorBanner.classList.remove('show');
            }, 5000);
        }

        // ===========================================
        // RECORDING CONTROL
        // ===========================================
        function startRecording() {
            if (!recognition) {
                showError(getText('NOT_SUPPORTED'));
                return;
            }

            if (isRecognitionActive) {
                console.log('Recognition already active, ignoring start');
                return;
            }

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                isRecognitionActive = false;

                if (e.message && e.message.includes('already')) {
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e2) {
                            showError('Error: ' + e2.message);
                        }
                    }, 200);
                } else {
                    showError('Error: ' + e.message);
                }
            }
        }

        function stopRecording() {
            if (!recognition || !isRecognitionActive) {
                return;
            }

            console.log('Stopping recording');
            clearRecordingTimeout();

            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
        }

        function handleButtonClick() {
            if (state === 'recording') {
                stopRecording();
            } else if (state === 'ready' || state === 'showing') {
                startRecording();
            }
        }

        // ===========================================
        // EVENT LISTENERS
        // ===========================================
        mainButton.addEventListener('click', handleButtonClick);
        mainButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleButtonClick();
        });

        document.addEventListener('touchend', (e) => {
            // Only prevent default on game screen to avoid double-tap zoom
            // But allow interactive buttons to work normally
            if (gameScreen.classList.contains('active')) {
                const isLangBtn = e.target.classList.contains('lang-btn');
                const isBackBtn = e.target.classList.contains('back-button');
                const isSpeakerBtn = e.target.id === 'speakerBtn';
                const isContinuousBtn = e.target.classList.contains('continuous-btn');
                if (!isLangBtn && !isBackBtn && !isSpeakerBtn && !isContinuousBtn) {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // ===========================================
        // INITIALIZATION
        // ===========================================
        function init() {
            // Request microphone permission
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                        console.log('Microphone permission granted');
                    })
                    .catch(err => {
                        console.log('Microphone permission not yet granted:', err);
                    });
            }

            // Initialize with Hebrew
            setLanguage('hebrew');
            console.log('Hebrew Voice App loaded');
        }

        init();
    </script>
</body>
</html>
