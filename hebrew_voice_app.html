<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6495ed">
    <title>Hebrew Voice Game</title>

    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">

    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cast/sdk/libs/cast_framework/cast_framework.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            padding: 4vmin;
            gap: 3vmin;
        }

        /* Mode Selection Screen */
        .mode-screen {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .mode-title {
            text-align: center;
            font-size: clamp(24px, 8vmin, 60px);
            font-weight: bold;
            color: #6495ed;
            padding: 2vmin 0;
        }

        .mode-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }

        .mode-button {
            flex: 1;
            border: none;
            border-radius: 30px;
            font-size: clamp(18px, 5vmin, 40px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 6px 6px 0 rgba(100, 100, 100, 0.4);
            border: 4px solid white;
            transition: transform 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1vmin;
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button .icon {
            font-size: clamp(30px, 10vmin, 80px);
        }

        .mode-button.free-speech { background-color: #32cd32; }
        .mode-button.spelling { background-color: #ff6b6b; }
        .mode-button.translation { background-color: #4ecdc4; }
        .mode-button.echo { background-color: #9b59b6; }
        .mode-button.disabled {
            background-color: #ccc;
            opacity: 0.6;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .game-screen.active {
            display: flex;
        }

        .mode-screen.hidden {
            display: none;
        }

        /* Top bar with back button and language toggle */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2vmin;
        }

        .back-button {
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 15px;
            padding: 2vmin 4vmin;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 rgba(100, 100, 100, 0.3);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .lang-toggle {
            display: flex;
            background: white;
            border-radius: 25px;
            padding: 0.5vmin;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .lang-btn {
            padding: 2vmin 4vmin;
            border: none;
            border-radius: 20px;
            font-size: clamp(14px, 3.5vmin, 24px);
            font-weight: bold;
            cursor: pointer;
            background: transparent;
            color: #666;
            transition: all 0.2s ease;
        }

        .lang-btn.active {
            background: #6495ed;
            color: white;
        }

        /* Continuous mode button */
        .continuous-btn {
            background: transparent;
            border: 3px solid #9b59b6;
            color: #9b59b6;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(18px, 4vmin, 28px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .continuous-btn.active {
            background: #9b59b6;
            color: white;
            animation: continuousPulse 1s ease-in-out infinite;
        }

        @keyframes continuousPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 15px 5px rgba(155, 89, 182, 0.3); }
        }

        /* Install / Fullscreen button */
        .tv-btn {
            background: transparent;
            border: 3px solid #6495ed;
            color: #6495ed;
            border-radius: 50%;
            width: clamp(56px, 12vmin, 80px);
            height: clamp(56px, 12vmin, 80px);
            font-size: clamp(24px, 6vmin, 40px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s ease;
            margin: 2vmin;
        }
        .tv-btn:active {
            transform: scale(0.95);
            background: #6495ed;
            color: white;
        }
        .tv-btn.hidden { display: none; }
        .tv-btn.casting {
            border-color: #32cd32;
            color: #32cd32;
            animation: continuousPulse 1.5s ease-in-out infinite;
        }

        /* Cast modal */
        .cast-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 6vmin;
        }
        .cast-modal-overlay.active { display: flex; }
        .cast-modal {
            background: white;
            border-radius: 20px;
            padding: 5vmin;
            max-width: 400px;
            width: 100%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .cast-modal h2 {
            color: #6495ed;
            font-size: clamp(18px, 5vmin, 28px);
            margin-bottom: 3vmin;
        }
        .cast-modal .steps {
            text-align: left;
            direction: ltr;
            font-size: clamp(14px, 3.5vmin, 20px);
            color: #333;
            line-height: 1.8;
            margin: 3vmin 0;
        }
        .cast-modal .steps li {
            margin: 1.5vmin 0;
        }
        .cast-modal .close-btn {
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 15px;
            padding: 2.5vmin 6vmin;
            font-size: clamp(16px, 4vmin, 22px);
            font-weight: bold;
            cursor: pointer;
            margin-top: 2vmin;
        }
        .cast-modal .close-btn:active { transform: scale(0.95); }

        /* Display area */
        .display-area {
            flex: 1;
            background: white;
            border-radius: 30px;
            border: 5px solid #6495ed;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 0;
        }

        .display-text {
            font-size: clamp(24px, 12vmin, 120px);
            font-weight: bold;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .text-blue { color: #6495ed; }
        .text-red { color: #ff5050; }
        .text-yellow { color: #daa520; }
        .text-black { color: #000; }
        .text-green { color: #32cd32; }
        .text-purple { color: #9b59b6; }

        .emoji-pop {
            font-size: clamp(60px, 20vmin, 180px);
            display: block;
            text-align: center;
            animation: emojiBounce 0.6s ease;
            line-height: 1.2;
        }

        @keyframes emojiBounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.3); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Button area */
        .button-area {
            height: 22vh;
            min-height: 80px;
        }

        .big-button {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 40px;
            font-size: clamp(20px, 6vmin, 48px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            outline: none;
            transition: transform 0.1s ease;
            box-shadow: 8px 8px 0 rgba(100, 100, 100, 0.5);
            border: 6px solid white;
        }

        .big-button:active {
            transform: scale(0.98);
        }

        .button-ready { background-color: #32cd32; }
        .button-recording {
            background-color: #ff5050;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        .button-processing {
            background-color: #ffd700;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.03); }
        }

        /* Error banner */
        .error-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff5050;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 18px;
            display: none;
            z-index: 100;
        }

        .error-banner.show {
            display: block;
        }

        /* Speaker button for TTS */
        .speaker-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(20px, 5vmin, 36px);
            cursor: pointer;
            display: none;
        }

        .speaker-btn.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .display-area {
            position: relative;
        }

        /* Spelling Bee Game UI */
        .difficulty-selector {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-selector.visible {
            display: flex;
        }

        .difficulty-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #6495ed;
            background: white;
            color: #6495ed;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-btn:active, .difficulty-btn.selected {
            background: #6495ed;
            color: white;
            transform: scale(0.95);
        }

        .game-controls {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-controls.visible {
            display: flex;
        }

        .game-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #32cd32;
            background: white;
            color: #32cd32;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-btn:active {
            background: #32cd32;
            color: white;
            transform: scale(0.95);
        }

        .game-btn.repeat {
            border-color: #ffa500;
            color: #ffa500;
        }

        .game-btn.repeat:active {
            background: #ffa500;
        }

        .spelling-letters {
            display: flex;
            flex-wrap: wrap;
            gap: 1vmin;
            justify-content: center;
            margin-top: 2vmin;
            font-size: clamp(20px, 6vmin, 40px);
        }

        .spelling-letter {
            min-width: clamp(30px, 6vmin, 50px);
            min-height: clamp(30px, 6vmin, 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ccc;
            border-radius: 10px;
            background: #f5f5f5;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .spelling-letter.correct {
            background: #32cd32;
            color: white;
            border-color: #32cd32;
            animation: correctPop 0.3s ease;
        }

        .spelling-letter.incorrect {
            background: #ff5050;
            color: white;
            border-color: #ff5050;
            animation: shake 0.3s ease;
        }

        @keyframes correctPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</head>
<body>
    <div id="errorBanner" class="error-banner"></div>

    <!-- Cast Instructions Modal -->
    <div id="castModal" class="cast-modal-overlay" onclick="closeCastModal(event)">
        <div class="cast-modal" onclick="event.stopPropagation()">
            <h2>&#128250; Cast to TV</h2>
            <ol class="steps">
                <li>Open Chrome menu (<b>&#8942;</b> top right)</li>
                <li>Tap <b>"Cast..."</b></li>
                <li>Select your <b>Mibox / TV</b></li>
                <li>Choose <b>"Cast tab"</b> if prompted</li>
            </ol>
            <p style="color:#888; font-size:clamp(12px,3vmin,16px); margin-bottom:2vmin;">
                The game displays on TV while you control from your phone.
            </p>
            <button class="close-btn" onclick="closeCastModal()">OK</button>
        </div>
    </div>

    <!-- Mode Selection Screen -->
    <div id="modeScreen" class="mode-screen">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <div class="mode-title" id="modeTitle" style="flex:1;">×‘×—×¨ ××©×—×§</div>
            <button class="tv-btn" onclick="handleInstallOrFullscreen()" title="Cast to TV">&#128250;</button>
        </div>
        <div class="mode-buttons">
            <button class="mode-button free-speech" onclick="startMode('free-speech')">
                <span class="icon">ğŸ¤</span>
                <span id="freeSpeechLabel">×“×™×‘×•×¨ ×—×•×¤×©×™</span>
            </button>
            <button class="mode-button spelling" onclick="startMode('spelling')">
                <span class="icon">ğŸ“</span>
                <span id="spellingLabel">××™×•×ª</span>
            </button>
            <button class="mode-button translation" onclick="startMode('translation')">
                <span class="icon">ğŸŒ</span>
                <span id="translationLabel">×ª×¨×’×•×</span>
            </button>
            <button class="mode-button echo" onclick="startMode('echo')">
                <span class="icon">ğŸ”„</span>
                <span id="echoLabel">×—×™×§×•×™</span>
            </button>
        </div>
    </div>

    <!-- Free Speech Game Screen -->
    <div id="gameScreen" class="game-screen">
        <div class="top-bar">
            <button class="back-button" onclick="goBack()">â† ×—×–×¨×”</button>
            <button class="continuous-btn" id="continuousBtn" onclick="toggleContinuous()">&#8734;</button>
            <button class="tv-btn" id="installBtn" onclick="handleInstallOrFullscreen()" title="Cast to TV">&#128250;</button>
            <div class="lang-toggle">
                <button class="lang-btn active" id="btnHebrew" onclick="setLanguage('hebrew')">×¢×‘×¨×™×ª</button>
                <button class="lang-btn" id="btnEnglish" onclick="setLanguage('english')">English</button>
            </div>
        </div>

        <!-- Difficulty Selector (for Spelling mode) -->
        <div id="difficultySelector" class="difficulty-selector">
            <button class="difficulty-btn" data-difficulty="easy">ğŸŸ¢ Easy / ×§×œ</button>
            <button class="difficulty-btn" data-difficulty="medium">ğŸŸ¡ Medium / ×‘×™× ×•× ×™</button>
            <button class="difficulty-btn" data-difficulty="hard">ğŸ”´ Hard / ×§×©×”</button>
        </div>

        <div class="display-area">
            <button id="speakerBtn" class="speaker-btn" onclick="handleSpeakerClick()">ğŸ”Š</button>
            <div id="displayText" class="display-text text-blue">×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!</div>
            <div id="spellingLetters" class="spelling-letters"></div>
        </div>

        <!-- Game Controls (for Spelling/Translation modes) -->
        <div id="gameControls" class="game-controls">
            <button class="game-btn repeat" onclick="repeatWord()">ğŸ” Repeat / ×—×–×•×¨</button>
            <button class="game-btn" onclick="nextWord()">â¡ï¸ Next / ×”×‘×</button>
        </div>

        <div class="button-area">
            <button id="mainButton" class="big-button button-ready">×œ×—×¥ ×œ×“×‘×¨!</button>
        </div>
    </div>

    <script>
        // ===========================================
        // PWA + INSTALL / FULLSCREEN
        // ===========================================

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('Service worker registered');
            }).catch(err => {
                console.log('Service worker registration skipped:', err.message);
            });
        }

        // Detect if running inside the Android APK
        const isAndroidApp = typeof AndroidBridge !== 'undefined' && AndroidBridge.isAndroidApp && AndroidBridge.isAndroidApp();

        // ===========================================
        // GOOGLE CAST API SETUP
        // ===========================================
        let castAPI = null;
        let castSession = null;

        function initCastAPI() {
            if (!window.cast || !window.cast.framework) {
                console.log('Cast API not available');
                return;
            }
            
            const context = cast.framework.CastContext.getInstance();
            context.setOptions({
                receiverApplicationId: cast.framework.CastReceiverApplicationClass.MEDIA_RECEIVER_APP_ID,
                autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
                resumeSavedSession: true
            });
            
            castAPI = context;
            
            // Listen for session changes
            context.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, onSessionStateChange);
        }

        function onSessionStateChange(event) {
            const session = event.session;
            if (session) {
                castSession = session;
                document.querySelector('.tv-btn').classList.add('casting');
            } else {
                castSession = null;
                document.querySelector('.tv-btn').classList.remove('casting');
            }
        }

        function startCast() {
            if (!castAPI) {
                initCastAPI();
            }
            if (castAPI) {
                castAPI.requestSession().then(
                    () => { console.log('Cast session started'); },
                    (error) => { console.error('Cast error:', error); }
                );
            } else {
                // Fallback to modal if Cast not available
                document.getElementById('castModal').classList.add('active');
            }
        }

        // Initialize Cast when loaded
        if (window.cast) {
            window['__castStarted'] = false;
            document.addEventListener('DOMContentLoaded', () => {
                // Small delay to ensure cast framework is ready
                setTimeout(initCastAPI, 1000);
            });
        }

        function handleInstallOrFullscreen() {
            // Inside APK: open Android's system cast / screen-mirror settings.
            if (isAndroidApp) {
                AndroidBridge.openCastSettings();
                return;
            }

            // Browser with Cast API: try to start casting
            if (window.cast && castAPI) {
                castAPI.requestSession().then(
                    () => { console.log('Cast started'); },
                    (error) => { 
                        console.log('Cast not available, showing instructions');
                        document.getElementById('castModal').classList.add('active'); 
                    }
                );
                return;
            }

            // Browser without Cast: show instructions modal
            document.getElementById('castModal').classList.add('active');
        }

        function closeCastModal(event) {
            // Close when clicking overlay background or the OK button
            if (!event || event.target === event.currentTarget) {
                document.getElementById('castModal').classList.remove('active');
            }
        }

        // ===========================================
        // LETTER NAMES FOR SPELLING
        // ===========================================
        const HEBREW_LETTER_NAMES = {
            '×': '×Ö¸×œÖ¶×£', '×‘': '×‘ÖµÖ¼×™×ª', '×’': '×’Ö´Ö¼×™×Ö¶×œ', '×“': '×“Ö¸Ö¼×œÖ¶×ª', '×”': '×”Öµ×',
            '×•': '×•Ö¸×•', '×–': '×–Ö·×™Ö´×Ÿ', '×—': '×—Öµ×™×ª', '×˜': '×˜Öµ×™×ª', '×™': '×™×•Ö¹×“',
            '×›': '×›Ö¸Ö¼×£', '×š': '×›Ö¸Ö¼×£ ×¡×•Ö¹×¤Ö´×™×ª', '×œ': '×œÖ¸×Ö¶×“', '×': '×Öµ×', '×': '×Öµ× ×¡×•Ö¹×¤Ö´×™×ª',
            '× ': '× ×•Ö¼×Ÿ', '×Ÿ': '× ×•Ö¼×Ÿ ×¡×•Ö¹×¤Ö´×™×ª', '×¡': '×¡Ö¸×Ö¶×š', '×¢': '×¢Ö·×™Ö´×Ÿ', '×¤': '×¤ÖµÖ¼×',
            '×£': '×¤ÖµÖ¼× ×¡×•Ö¹×¤Ö´×™×ª', '×¦': '×¦Ö¸×“Ö´×™', '×¥': '×¦Ö¸×“Ö´×™ ×¡×•Ö¹×¤Ö´×™×ª', '×§': '×§×•Ö¹×£',
            '×¨': '×¨Öµ×™×©×', '×©': '×©Ö´××™×Ÿ', '×ª': '×ªÖ¸Ö¼×•'
        };

        // ===========================================
        // LANGUAGE CONFIGURATION
        // ===========================================
        const LANGUAGES = {
            hebrew: {
                code: 'he-IL',
                dir: 'rtl',
                text: {
                    SELECT_MODE: '×‘×—×¨ ××©×—×§',
                    FREE_SPEECH: '×“×™×‘×•×¨ ×—×•×¤×©×™',
                    SPELLING: '××™×•×ª',
                    TRANSLATION: '×ª×¨×’×•×',
                    ECHO: '×—×™×§×•×™',
                    TRANSLATING: '××ª×¨×’×...',
                    TRANSLATE_TO: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª ×œ×ª×¨×’×•× ×œ×× ×’×œ×™×ª',
                    TRANSLATION_ERROR: '×©×’×™××ª ×ª×¨×’×•×',
                    BACK: 'â† ×—×–×¨×”',
                    TAP_TO_SPEAK: '×œ×—×¥ ×œ×“×‘×¨!',
                    RECORDING: '××§×œ×™×˜... (×œ×—×¥ ×œ×¢×¦×™×¨×”)',
                    PROCESSING: '××¢×‘×“...',
                    LISTENING: '××§×©×™×‘...',
                    THINKING: '×—×•×©×‘...',
                    SAY_SOMETHING: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!',
                    NOT_UNDERSTOOD: '×œ× ×”×‘× ×ª×™',
                    NETWORK_ERROR: '×©×’×™××ª ×¨×©×ª',
                    NOT_SUPPORTED: '×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×§×•×œ',
                    NEED_PERMISSION: '× ×“×¨×©×ª ×”×¨×©××ª ××™×§×¨×•×¤×•×Ÿ',
                    CONTINUOUS: '×¨×¦×£',
                    CONTINUOUS_ON: '×¨×¦×£ ×¤×¢×™×œ'
                }
            },
            english: {
                code: 'en-US',
                dir: 'ltr',
                text: {
                    SELECT_MODE: 'Select Game',
                    FREE_SPEECH: 'Free Speech',
                    SPELLING: 'Spelling',
                    TRANSLATION: 'Translation',
                    ECHO: 'Echo Practice',
                    TRANSLATING: 'Translating...',
                    TRANSLATE_TO: 'Say something in English to translate to Hebrew',
                    TRANSLATION_ERROR: 'Translation error',
                    BACK: 'â† Back',
                    TAP_TO_SPEAK: 'Tap to Speak!',
                    RECORDING: 'Recording... (tap to stop)',
                    PROCESSING: 'Processing...',
                    LISTENING: 'Listening...',
                    THINKING: 'Thinking...',
                    SAY_SOMETHING: 'Say something in English!',
                    NOT_UNDERSTOOD: "Didn't understand",
                    NETWORK_ERROR: 'Network error',
                    NOT_SUPPORTED: 'Browser does not support speech recognition',
                    NEED_PERMISSION: 'Microphone permission required',
                    CONTINUOUS: 'Loop',
                    CONTINUOUS_ON: 'Loop Active'
                }
            }
        };

        // ===========================================
        // STATE
        // ===========================================
        let currentLang = 'hebrew';
        let currentMode = null;
        let state = 'ready';
        let recognition = null;
        let recordingTimeout = null;
        let isRecognitionActive = false;
        let lastRecognizedText = '';
        let continuousMode = false;

        // Spelling Bee Game State
        let wordsData = null;  // Loaded from words.json
        let spellingGame = {
            difficulty: null,
            currentWord: null,
            targetWord: null,
            userSpelling: [],
            wordList: [],
            score: 0
        };

        // Echo Practice Game State
        let echoGame = {
            difficulty: null,
            currentWord: null,
            wordList: [],
            score: 0,
            totalAttempts: 0
        };

        const MAX_RECORDING_TIME = 10000;

        // Load words.json on startup
        fetch('words.json')
            .then(response => response.json())
            .then(data => {
                wordsData = data;
                console.log('Words loaded:', wordsData);
            })
            .catch(error => console.error('Failed to load words.json:', error));

        function getEmoji(word) {
            if (!wordsData || !wordsData.emoji || !word) return '';
            return wordsData.emoji[word.trim()] || wordsData.emoji[word.trim().toLowerCase()] || '';
        }

        function emojiHtml(word) {
            const emoji = getEmoji(word);
            if (!emoji) return '';
            return `<span class="emoji-pop">${emoji}</span>`;
        }

        // ===========================================
        // ELEMENTS
        // ===========================================
        const modeScreen = document.getElementById('modeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const modeTitle = document.getElementById('modeTitle');
        const freeSpeechLabel = document.getElementById('freeSpeechLabel');
        const spellingLabel = document.getElementById('spellingLabel');
        const translationLabel = document.getElementById('translationLabel');
        const echoLabel = document.getElementById('echoLabel');
        const displayText = document.getElementById('displayText');
        const mainButton = document.getElementById('mainButton');
        const errorBanner = document.getElementById('errorBanner');
        const btnHebrew = document.getElementById('btnHebrew');
        const btnEnglish = document.getElementById('btnEnglish');
        const speakerBtn = document.getElementById('speakerBtn');
        const backButton = document.querySelector('.back-button');
        const continuousBtn = document.getElementById('continuousBtn');
        const difficultySelector = document.getElementById('difficultySelector');
        const gameControls = document.getElementById('gameControls');
        const spellingLetters = document.getElementById('spellingLetters');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');

        // ===========================================
        // TEXT-TO-SPEECH
        // ===========================================
        const synth = window.speechSynthesis;

        // Use native Android TTS when running inside the APK
        const useNativeTts = isAndroidApp && typeof AndroidBridge.speak === 'function';

        // Estimate speech duration for native TTS (no onend callback available)
        function estimateSpeechDuration(text, rate = 0.8) {
            // ~100ms per character at normal rate, adjusted for speech rate
            return Math.max(800, (text.length * 100) / rate + 500);
        }

        function nativeSpeak(text, langCode, onComplete = null) {
            AndroidBridge.speak(text, langCode);
            if (onComplete) {
                setTimeout(onComplete, estimateSpeechDuration(text));
            }
        }

        function stopTts() {
            if (useNativeTts) {
                AndroidBridge.stopSpeaking();
            } else if (synth) {
                synth.cancel();
            }
        }

        function speakText(text = null, onComplete = null) {
            const textToSpeak = text || lastRecognizedText;
            if (!textToSpeak) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();
            const langCode = LANGUAGES[currentLang].code;

            if (useNativeTts) {
                nativeSpeak(textToSpeak, langCode, () => {
                    if (onComplete) {
                        onComplete();
                    } else if (continuousMode) {
                        restartListeningAfterDelay();
                    }
                });
                return;
            }

            if (!synth) { if (onComplete) onComplete(); return; }

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = langCode;
            utterance.rate = 0.8;

            utterance.onend = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            utterance.onerror = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            synth.speak(utterance);
        }

        // Handle speaker button click - speaks in correct language based on mode
        function handleSpeakerClick() {
            if (!lastRecognizedText) return;

            if (currentMode === 'translation') {
                // In translation mode, lastRecognizedText is in the TARGET language
                const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';
                speakInLanguage(lastRecognizedText, targetLangCode);
            } else {
                speakText();
            }
        }

        // Speak and spell: say each word then spell it letter by letter
        function speakAndSpell(text) {
            if (!text) {
                if (continuousMode) restartListeningAfterDelay();
                return;
            }

            stopTts();
            const words = text.split(/\s+/).filter(w => w.length > 0);
            const langCode = LANGUAGES[currentLang].code;
            const isHebrew = currentLang === 'hebrew';

            if (useNativeTts) {
                // For native TTS, queue all speech sequentially with delays
                let totalDelay = 0;
                words.forEach((word, wordIndex) => {
                    // Say the whole word
                    setTimeout(() => AndroidBridge.speak(word, langCode), totalDelay);
                    totalDelay += estimateSpeechDuration(word);

                    // Spell each letter
                    const letters = [...word];
                    letters.forEach(letter => {
                        let letterName;
                        if (isHebrew && HEBREW_LETTER_NAMES[letter]) {
                            letterName = HEBREW_LETTER_NAMES[letter];
                        } else {
                            letterName = letter.toUpperCase();
                        }
                        setTimeout(() => AndroidBridge.speak(letterName, langCode), totalDelay);
                        totalDelay += estimateSpeechDuration(letterName, 0.7);
                    });

                    if (wordIndex < words.length - 1) {
                        totalDelay += 500; // pause between words
                    }
                });

                if (continuousMode) {
                    setTimeout(() => restartListeningAfterDelay(), totalDelay);
                }
                return;
            }

            if (!synth) { if (continuousMode) restartListeningAfterDelay(); return; }

            let lastUtterance = null;

            // Queue all utterances
            words.forEach((word, wordIndex) => {
                // Say the whole word first
                const wordUtterance = new SpeechSynthesisUtterance(word);
                wordUtterance.lang = langCode;
                wordUtterance.rate = 0.8;
                synth.speak(wordUtterance);
                lastUtterance = wordUtterance;

                // Then spell each letter
                const letters = [...word];
                letters.forEach((letter, letterIndex) => {
                    let letterName;
                    if (isHebrew && HEBREW_LETTER_NAMES[letter]) {
                        letterName = HEBREW_LETTER_NAMES[letter];
                    } else {
                        // For English or unknown characters, just say the letter
                        letterName = letter.toUpperCase();
                    }

                    const letterUtterance = new SpeechSynthesisUtterance(letterName);
                    letterUtterance.lang = langCode;
                    letterUtterance.rate = 0.7;
                    synth.speak(letterUtterance);
                    lastUtterance = letterUtterance;
                });

                // Add a pause between words (using a silent utterance or short pause word)
                if (wordIndex < words.length - 1) {
                    const pauseUtterance = new SpeechSynthesisUtterance('.');
                    pauseUtterance.lang = langCode;
                    pauseUtterance.rate = 0.3;
                    pauseUtterance.volume = 0;
                    synth.speak(pauseUtterance);
                    lastUtterance = pauseUtterance;
                }
            });

            // Restart listening after spelling completes in continuous mode
            if (lastUtterance && continuousMode) {
                lastUtterance.onend = () => {
                    restartListeningAfterDelay();
                };
                lastUtterance.onerror = () => {
                    restartListeningAfterDelay();
                };
            }
        }

        // ===========================================
        // TRANSLATION API
        // ===========================================
        async function translateText(text, fromLang, toLang) {
            // Use MyMemory free translation API
            const langPair = `${fromLang}|${toLang}`;
            const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${langPair}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.responseStatus === 200 && data.responseData) {
                    return data.responseData.translatedText;
                } else {
                    console.error('Translation API error:', data);
                    return null;
                }
            } catch (error) {
                console.error('Translation fetch error:', error);
                return null;
            }
        }

        // Speak text in a specific language (not necessarily current language)
        function speakInLanguage(text, langCode, onComplete = null) {
            if (!text) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();

            if (useNativeTts) {
                nativeSpeak(text, langCode, () => {
                    if (onComplete) {
                        onComplete();
                    } else if (continuousMode) {
                        restartListeningAfterDelay();
                    }
                });
                return;
            }

            if (!synth) { if (onComplete) onComplete(); return; }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.8;

            utterance.onend = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            utterance.onerror = () => {
                if (onComplete) {
                    onComplete();
                } else if (continuousMode) {
                    restartListeningAfterDelay();
                }
            };

            synth.speak(utterance);
        }

        // ===========================================
        // SPELLING BEE GAME FUNCTIONS
        // ===========================================
        function selectDifficulty(difficulty) {
            if (!wordsData) {
                showError('Word list not loaded yet');
                return;
            }

            if (currentMode === 'spelling') {
                // Spelling Bee mode
                spellingGame.difficulty = difficulty;
                spellingGame.wordList = wordsData.spelling[currentLang][difficulty] || [];
                
                if (spellingGame.wordList.length === 0) {
                    showError('No words available for this difficulty');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextWord();
            } else if (currentMode === 'echo') {
                // Echo Practice mode
                echoGame.difficulty = difficulty;
                const echoWords = wordsData.echo && wordsData.echo[currentLang];
                echoGame.wordList = (echoWords && echoWords[difficulty]) || [];
                
                console.log('Echo mode - difficulty:', difficulty, 'words:', echoGame.wordList);
                
                if (echoGame.wordList.length === 0) {
                    showError('No echo words for this level. Try another.');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextEchoWord();
            }
        }

        // ECHO PRACTICE GAME FUNCTIONS
        // ===========================================
        function nextEchoWord() {
            if (!echoGame.wordList || echoGame.wordList.length === 0) {
                showError('No words available');
                return;
            }

            // Pick random word
            const randomIndex = Math.floor(Math.random() * echoGame.wordList.length);
            echoGame.currentWord = echoGame.wordList[randomIndex];
            
            // Update display - prompt user to listen
            displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘ ×œ××™×œ×”...' : 'Listen to the word...';
            displayText.className = 'display-text text-purple';
            
            // Show record button 
            mainButton.style.display = '';
            mainButton.textContent = 'ğŸ¤';
            mainButton.className = 'big-button button-ready';
            setState('ready');
            
            // Speak the word automatically, then update UI to prompt recording
            setTimeout(() => {
                speakText(echoGame.currentWord);
                // After word is spoken, show emoji + prompt user to repeat
                setTimeout(() => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Now you! Tap the microphone`;
                }, 1500);
            }, 500);
        }

        function handleEchoRecordingComplete(text) {
            if (!text || text.trim() === '') {
                showError(currentLang === 'hebrew' ? '×œ× ×”×‘× ×ª×™, × ×¡×” ×©×•×‘' : "I didn't understand, try again");
                setState('ready');
                return;
            }

            echoGame.totalAttempts++;

            // Show what user said and encourage with emoji
            const echoEmoji = emojiHtml(echoGame.currentWord);
            displayText.innerHTML = currentLang === 'hebrew'
                ? `${echoEmoji}×××¨×ª: <b>${text}</b><br>××¢×•×œ×”! ğŸ‘<br><small>××™×œ×” ×”×‘××” ×‘×¢×•×“ ×©× ×™×™×”...</small>`
                : `${echoEmoji}You said: <b>${text}</b><br>Great! ğŸ‘<br><small>Next word coming...</small>`;
            displayText.className = 'display-text text-purple';

            // Play next word after delay
            setTimeout(() => {
                nextEchoWord();
            }, 2500);
        }

        function nextWord() {
            if (currentMode === 'echo') {
                // Echo mode - go to next word
                nextEchoWord();
            } else if (currentMode === 'spelling') {
                // Spelling mode - pick next spelling word
                if (!spellingGame.wordList || spellingGame.wordList.length === 0) {
                    showError('No words available');
                    return;
                }

                // Pick random word
                const randomIndex = Math.floor(Math.random() * spellingGame.wordList.length);
                spellingGame.targetWord = spellingGame.wordList[randomIndex];
                spellingGame.currentWord = spellingGame.targetWord;
                spellingGame.userSpelling = [];

                // Reset spelling letters display
                updateSpellingDisplay();

                // Speak the word
                displayText.textContent = 'ğŸ‘‚ Listen...';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = '';  // Show button for user to spell

                speakText(spellingGame.targetWord, () => {
                    // After speaking, show instruction
                    displayText.textContent = currentLang === 'hebrew' ? '×¢×›×©×™×• ××ª×”! ××•×ª ××—×¨ ××•×ª' : 'Your turn! Spell it letter by letter';
                    displayText.className = 'display-text text-green';
                    setState('ready');
                });
            }
        }

        function repeatWord() {
            if (currentMode === 'echo') {
                // Echo mode - repeat the current word
                if (!echoGame.currentWord) return;

                displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘ ×œ××™×œ×”...' : 'Listen to the word...';
                displayText.className = 'display-text text-purple';

                speakText(echoGame.currentWord, () => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Now you! Tap the microphone`;
                });
            } else if (currentMode === 'spelling') {
                // Spelling mode - repeat the target word
                if (!spellingGame.targetWord) return;

                displayText.textContent = 'ğŸ‘‚ Listen...';
                displayText.className = 'display-text text-blue';

                speakText(spellingGame.targetWord, () => {
                    displayText.textContent = currentLang === 'hebrew' ? '×¢×›×©×™×• ××ª×”! ××•×ª ××—×¨ ××•×ª' : 'Your turn! Spell it letter by letter';
                    displayText.className = 'display-text text-green';
                });
            }
        }

        function updateSpellingDisplay() {
            if (!spellingGame.targetWord) {
                spellingLetters.innerHTML = '';
                return;
            }

            const letters = [...spellingGame.targetWord];
            spellingLetters.innerHTML = letters.map((letter, index) => {
                let className = 'spelling-letter';
                let content = '_';
                
                if (spellingGame.userSpelling[index]) {
                    content = spellingGame.userSpelling[index].char;
                    className += spellingGame.userSpelling[index].correct ? ' correct' : ' incorrect';
                }
                
                return `<div class="${className}">${content}</div>`;
            }).join('');
        }

        function checkSpelling(spokenText) {
            if (!spellingGame.targetWord) return;
            
            // Normalize the spoken text
            const normalized = spokenText.trim().toLowerCase();
            const targetLetters = [...spellingGame.targetWord.toLowerCase()];
            
            // Track which positions are already filled
            const filledPositions = new Set(
                Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k])
                    .map(k => parseInt(k))
            );
            
            // Check if user spoke a single letter
            let matchedLetterIndex = -1;
            
            // For Hebrew, check against letter names
            if (currentLang === 'hebrew') {
                for (const [letter, name] of Object.entries(HEBREW_LETTER_NAMES)) {
                    if (normalized.includes(name.toLowerCase()) || normalized.includes(letter)) {
                        // Find first unfilled position for this letter
                        for (let i = 0; i < targetLetters.length; i++) {
                            if (targetLetters[i] === letter.toLowerCase() && !filledPositions.has(i)) {
                                matchedLetterIndex = i;
                                spellingGame.userSpelling[i] = { char: letter, correct: true };
                                break;
                            }
                        }
                        break;
                    }
                }
            } else {
                // For English, check if it's a single letter
                if (normalized.length === 1 && /[a-z]/.test(normalized)) {
                    for (let i = 0; i < targetLetters.length; i++) {
                        if (targetLetters[i] === normalized && !filledPositions.has(i)) {
                            matchedLetterIndex = i;
                            spellingGame.userSpelling[i] = { char: normalized, correct: true };
                            break;
                        }
                    }
                }
            }
            
            if (matchedLetterIndex >= 0) {
                // Correct letter!
                updateSpellingDisplay();
                
                // Check if word is complete (count filled positions)
                const filledCount = Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k] && spellingGame.userSpelling[k].correct)
                    .length;
                
                if (filledCount === targetLetters.length) {
                    // Word completed successfully! Show emoji celebration
                    const spellingEmoji = emojiHtml(spellingGame.targetWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${spellingEmoji}ğŸ‰ ××¦×•×™×Ÿ! ××™×œ×” × ×›×•× ×”!`
                        : `${spellingEmoji}ğŸ‰ Excellent! Correct!`;
                    displayText.className = 'display-text text-green';
                    speakText(currentLang === 'hebrew' ? '××¦×•×™×Ÿ' : 'Excellent');
                    
                    // Auto next word after delay
                    setTimeout(nextWord, 2000);
                } else {
                    // Continue spelling
                    displayText.textContent = currentLang === 'hebrew' ? '× ×›×•×Ÿ! âœ“ ×”××©×š...' : 'Correct! âœ“ Continue...';
                    displayText.className = 'display-text text-green';
                }
            } else {
                // Incorrect or unrecognized
                displayText.textContent = currentLang === 'hebrew' ? 'âŒ × ×¡×” ×©×•×‘' : 'âŒ Try again';
                displayText.className = 'display-text text-red';
            }
        }

        // ===========================================
        // CONTINUOUS MODE
        // ===========================================
        function toggleContinuous() {
            continuousMode = !continuousMode;
            updateContinuousUI();
            console.log('Continuous mode:', continuousMode);

            if (continuousMode && (state === 'ready' || state === 'showing')) {
                // Start listening immediately when enabling continuous mode
                startRecording();
            } else if (!continuousMode && isRecognitionActive) {
                // Stop if we're currently recording
                stopRecording();
            }
        }

        function updateContinuousUI() {
            if (continuousMode) {
                continuousBtn.classList.add('active');
                continuousBtn.title = getText('CONTINUOUS_ON');
            } else {
                continuousBtn.classList.remove('active');
                continuousBtn.title = getText('CONTINUOUS');
            }
        }

        function restartListeningAfterDelay(delay = 500) {
            if (continuousMode && !isRecognitionActive) {
                setTimeout(() => {
                    if (continuousMode && (state === 'ready' || state === 'showing')) {
                        console.log('Continuous mode: restarting listening');
                        startRecording();
                    }
                }, delay);
            }
        }

        // ===========================================
        // LANGUAGE FUNCTIONS
        // ===========================================
        function getText(key) {
            return LANGUAGES[currentLang].text[key];
        }

        function setLanguage(lang) {
            currentLang = lang;
            const langConfig = LANGUAGES[lang];

            // Update document direction
            document.documentElement.lang = lang === 'hebrew' ? 'he' : 'en';
            document.documentElement.dir = langConfig.dir;

            // Update toggle buttons
            btnHebrew.classList.toggle('active', lang === 'hebrew');
            btnEnglish.classList.toggle('active', lang === 'english');

            // Update UI text
            updateUIText();

            // Reinitialize speech recognition with new language
            initSpeechRecognition();

            // Reset state
            if (state !== 'ready') {
                stopRecording();
            }
            setState('ready');
        }

        function updateUIText() {
            // Mode screen
            modeTitle.textContent = getText('SELECT_MODE');
            freeSpeechLabel.textContent = getText('FREE_SPEECH');
            spellingLabel.textContent = getText('SPELLING');
            translationLabel.textContent = getText('TRANSLATION');
            echoLabel.textContent = getText('ECHO');

            // Game screen
            backButton.textContent = getText('BACK');

            // Update based on current state
            if (state === 'ready') {
                if (currentMode === 'translation') {
                    displayText.textContent = getText('TRANSLATE_TO');
                } else {
                    displayText.textContent = getText('SAY_SOMETHING');
                }
                mainButton.textContent = getText('TAP_TO_SPEAK');
            }
        }

        // ===========================================
        // MODE NAVIGATION
        // ===========================================
        function startMode(mode) {
            currentMode = mode;
            modeScreen.classList.add('hidden');
            gameScreen.classList.add('active');
            
            // Reset UI elements
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            
            // Mode-specific initialization
            if (mode === 'spelling') {
                // Show difficulty selector for spelling mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = 'none';
                
                // Reset spelling game state
                spellingGame.difficulty = null;
                spellingGame.currentWord = null;
                spellingGame.targetWord = null;
                spellingGame.userSpelling = [];
                spellingGame.wordList = [];
            } else if (mode === 'echo') {
                // Show difficulty selector for echo mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-purple';
                mainButton.style.display = 'none';
                
                // Reset echo game state
                echoGame.difficulty = null;
                echoGame.currentWord = null;
                echoGame.wordList = [];
                echoGame.score = 0;
                
                // Check if wordsData is loaded
                if (!wordsData || !wordsData.echo) {
                    displayText.textContent = currentLang === 'hebrew' ? '×˜×•×¢×Ÿ ××™×œ×™×...' : 'Loading words...';
                }
            } else {
                // For free-speech and translation modes, show main button
                mainButton.style.display = '';
                setState('ready');
            }
        }

        function goBack() {
            if (isRecognitionActive) {
                stopRecording();
            }
            // Disable continuous mode when going back
            continuousMode = false;
            updateContinuousUI();

            currentMode = null;
            lastRecognizedText = '';
            speakerBtn.classList.remove('visible');
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            mainButton.style.display = '';
            gameScreen.classList.remove('active');
            modeScreen.classList.remove('hidden');
        }

        // ===========================================
        // SPEECH RECOGNITION
        // ===========================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        function initSpeechRecognition() {
            if (!SpeechRecognition) {
                showError(getText('NOT_SUPPORTED') + ' - Use Chrome');
                return;
            }

            // Stop existing recognition
            if (recognition) {
                try {
                    recognition.abort();
                } catch (e) {}
            }

            recognition = new SpeechRecognition();
            recognition.lang = LANGUAGES[currentLang].code;
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log('Recognition started');
                isRecognitionActive = true;
                setState('recording');

                recordingTimeout = setTimeout(() => {
                    console.log('Auto-stopping after timeout');
                    stopRecording();
                }, MAX_RECORDING_TIME);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    console.log('Final:', finalTranscript);
                    clearRecordingTimeout();
                    showResult(finalTranscript);
                } else if (interimTranscript) {
                    console.log('Interim:', interimTranscript);
                    displayText.textContent = interimTranscript;
                    displayText.className = 'display-text text-black';
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                clearRecordingTimeout();
                isRecognitionActive = false;

                switch (event.error) {
                    case 'not-allowed':
                        showError(getText('NEED_PERMISSION'));
                        showResult(getText('NEED_PERMISSION'));
                        break;
                    case 'network':
                        showResult(getText('NETWORK_ERROR'));
                        break;
                    case 'no-speech':
                        showResult(getText('NOT_UNDERSTOOD'));
                        break;
                    case 'aborted':
                        setState('ready');
                        break;
                    default:
                        showResult(getText('NOT_UNDERSTOOD'));
                }
            };

            recognition.onend = () => {
                console.log('Recognition ended');
                clearRecordingTimeout();
                isRecognitionActive = false;

                if (state === 'recording') {
                    showResult(getText('NOT_UNDERSTOOD'));
                }
            };
        }

        function clearRecordingTimeout() {
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
        }

        // ===========================================
        // STATE MANAGEMENT
        // ===========================================
        function setState(newState) {
            state = newState;

            switch (state) {
                case 'ready':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    // Show appropriate prompt based on mode
                    if (currentMode === 'translation') {
                        displayText.textContent = getText('TRANSLATE_TO');
                    } else {
                        displayText.textContent = getText('SAY_SOMETHING');
                    }
                    displayText.className = 'display-text text-blue';
                    break;

                case 'recording':
                    mainButton.textContent = getText('RECORDING');
                    mainButton.className = 'big-button button-recording';
                    displayText.textContent = getText('LISTENING');
                    displayText.className = 'display-text text-red';
                    speakerBtn.classList.remove('visible');
                    break;

                case 'processing':
                    mainButton.textContent = getText('PROCESSING');
                    mainButton.className = 'big-button button-processing';
                    displayText.textContent = getText('THINKING');
                    displayText.className = 'display-text text-yellow';
                    break;

                case 'showing':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    break;
            }
        }

        function showResult(text) {
            const isError = text === getText('NOT_UNDERSTOOD') ||
                           text === getText('NETWORK_ERROR') ||
                           text === getText('NEED_PERMISSION');

            // Handle translation mode separately
            if (currentMode === 'translation' && !isError) {
                handleTranslationResult(text);
                return;
            }

            // Handle spelling mode game separately
            if (currentMode === 'spelling' && !isError && spellingGame.targetWord) {
                checkSpelling(text);
                // Stay in ready state to continue spelling
                setState('ready');
                return;
            }

            // Handle echo mode - encourage and play next word
            if (currentMode === 'echo' && !isError) {
                handleEchoRecordingComplete(text);
                return;
            }

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';
            const resultEmoji = isError ? '' : emojiHtml(text);
            displayText.innerHTML = resultEmoji ? `${resultEmoji}${text}` : text;
            displayText.className = 'display-text text-black';

            // Store for TTS and show speaker button
            if (!isError) {
                lastRecognizedText = text;
                speakerBtn.classList.add('visible');

                // In free speech mode with continuous, speak the result then restart
                if (currentMode === 'free-speech' && continuousMode) {
                    setTimeout(() => speakText(text), 300);
                }
            } else {
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');

                // In continuous mode, keep listening even on errors
                if (continuousMode) {
                    restartListeningAfterDelay(1000);
                }
            }
        }

        async function handleTranslationResult(spokenText) {
            // Show translating state
            state = 'processing';
            mainButton.textContent = getText('PROCESSING');
            mainButton.className = 'big-button button-processing';
            displayText.textContent = getText('TRANSLATING');
            displayText.className = 'display-text text-yellow';

            // Determine source and target languages
            const fromLang = currentLang === 'hebrew' ? 'he' : 'en';
            const toLang = currentLang === 'hebrew' ? 'en' : 'he';
            const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';

            // Translate
            const translation = await translateText(spokenText, fromLang, toLang);

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';

            if (translation) {
                // Show both original and translation with emoji
                const transEmoji = emojiHtml(spokenText) || emojiHtml(translation);
                displayText.innerHTML = `${transEmoji}<div style="font-size: 0.5em; color: #888; margin-bottom: 10px;">${spokenText}</div>${translation}`;
                displayText.className = 'display-text text-black';
                lastRecognizedText = translation;
                speakerBtn.classList.add('visible');

                // Speak the translation in target language
                setTimeout(() => {
                    speakInLanguage(translation, targetLangCode, continuousMode ? () => restartListeningAfterDelay() : null);
                }, 300);
            } else {
                displayText.textContent = getText('TRANSLATION_ERROR');
                displayText.className = 'display-text text-red';
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');

                if (continuousMode) {
                    restartListeningAfterDelay(1000);
                }
            }
        }

        function showError(message) {
            errorBanner.textContent = message;
            errorBanner.classList.add('show');
            setTimeout(() => {
                errorBanner.classList.remove('show');
            }, 5000);
        }

        // ===========================================
        // RECORDING CONTROL
        // ===========================================
        function startRecording() {
            if (!recognition) {
                showError(getText('NOT_SUPPORTED'));
                return;
            }

            if (isRecognitionActive) {
                console.log('Recognition already active, ignoring start');
                return;
            }

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                isRecognitionActive = false;

                if (e.message && e.message.includes('already')) {
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e2) {
                            showError('Error: ' + e2.message);
                        }
                    }, 200);
                } else {
                    showError('Error: ' + e.message);
                }
            }
        }

        function stopRecording() {
            if (!recognition || !isRecognitionActive) {
                return;
            }

            console.log('Stopping recording');
            clearRecordingTimeout();

            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
        }

        function handleButtonClick() {
            if (state === 'recording') {
                stopRecording();
            } else if (state === 'ready' || state === 'showing') {
                startRecording();
            }
        }

        // ===========================================
        // EVENT LISTENERS
        // ===========================================
        mainButton.addEventListener('click', handleButtonClick);
        mainButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleButtonClick();
        });

        // Add event listeners for difficulty buttons
        difficultyBtns.forEach((btn) => {
            const difficulty = btn.dataset.difficulty;
            
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectDifficulty(difficulty);
            });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectDifficulty(difficulty);
            });
        });

        document.addEventListener('touchend', (e) => {
            // Only prevent default on game screen to avoid double-tap zoom
            // But allow interactive buttons to work normally
            if (gameScreen.classList.contains('active')) {
                const isLangBtn = e.target.classList.contains('lang-btn');
                const isBackBtn = e.target.classList.contains('back-button');
                const isSpeakerBtn = e.target.id === 'speakerBtn';
                const isContinuousBtn = e.target.classList.contains('continuous-btn');
                const isDifficultyBtn = e.target.classList.contains('difficulty-btn');
                const isGameBtn = e.target.classList.contains('game-btn');
                if (!isLangBtn && !isBackBtn && !isSpeakerBtn && !isContinuousBtn && !isDifficultyBtn && !isGameBtn) {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // ===========================================
        // INITIALIZATION
        // ===========================================
        function init() {
            // Request microphone permission
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                        console.log('Microphone permission granted');
                    })
                    .catch(err => {
                        console.log('Microphone permission not yet granted:', err);
                    });
            }

            // Initialize with Hebrew
            setLanguage('hebrew');
            console.log('Hebrew Voice App loaded');
        }

        init();
    </script>
</body>
</html>
