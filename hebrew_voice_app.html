<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6495ed">
    <title>Hebrew Voice Game</title>

    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            touch-action: manipulation;
        }

        body {
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            padding: 4vmin;
            gap: 3vmin;
            touch-action: manipulation;
        }

        /* Mode Selection Screen */
        .mode-screen {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .mode-title {
            text-align: center;
            font-size: clamp(24px, 8vmin, 60px);
            font-weight: bold;
            color: #6495ed;
            padding: 2vmin 0;
        }

        .mode-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }

        .mode-button {
            flex: 1;
            border: none;
            border-radius: 30px;
            font-size: clamp(18px, 5vmin, 40px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 6px 6px 0 rgba(100, 100, 100, 0.4);
            border: 4px solid white;
            transition: transform 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1vmin;
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button .icon {
            font-size: clamp(30px, 10vmin, 80px);
        }

        .mode-button.free-speech { background-color: #32cd32; }
        .mode-button.spelling { background-color: #ff6b6b; }
        .mode-button.translation { background-color: #4ecdc4; }
        .mode-button.echo { background-color: #9b59b6; }
        .mode-button.disabled {
            background-color: #ccc;
            opacity: 0.6;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .game-screen.active {
            display: flex;
        }

        .mode-screen.hidden {
            display: none;
        }

        /* Top bar with back button and language toggle */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2vmin;
        }

        .back-button {
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 15px;
            padding: 2vmin 4vmin;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 rgba(100, 100, 100, 0.3);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .lang-toggle {
            display: flex;
            background: white;
            border-radius: 25px;
            padding: 0.5vmin;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .lang-btn {
            padding: 2vmin 4vmin;
            border: none;
            border-radius: 20px;
            font-size: clamp(14px, 3.5vmin, 24px);
            font-weight: bold;
            cursor: pointer;
            background: transparent;
            color: #666;
            transition: all 0.2s ease;
        }

        .lang-btn.active {
            background: #6495ed;
            color: white;
        }

        /* Button disabled during TTS */
        .button-speaking {
            background-color: #b0b0b0;
            cursor: not-allowed;
        }

        /* Display area */
        .display-area {
            flex: 1;
            background: white;
            border-radius: 30px;
            border: 5px solid #6495ed;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 0;
        }

        .display-text {
            font-size: clamp(24px, 12vmin, 120px);
            font-weight: bold;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .text-blue { color: #6495ed; }
        .text-red { color: #ff5050; }
        .text-yellow { color: #daa520; }
        .text-black { color: #000; }
        .text-green { color: #32cd32; }
        .text-purple { color: #9b59b6; }

        .emoji-pop {
            font-size: clamp(60px, 20vmin, 180px);
            display: block;
            text-align: center;
            animation: emojiBounce 0.6s ease;
            line-height: 1.2;
        }

        @keyframes emojiBounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.3); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Button area */
        .button-area {
            height: 22vh;
            min-height: 80px;
        }

        .big-button {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 40px;
            font-size: clamp(20px, 6vmin, 48px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            outline: none;
            transition: transform 0.1s ease;
            box-shadow: 8px 8px 0 rgba(100, 100, 100, 0.5);
            border: 6px solid white;
        }

        .big-button:active {
            transform: scale(0.98);
        }

        .button-ready { background-color: #32cd32; }
        .button-recording {
            background-color: #ff5050;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        .button-processing {
            background-color: #ffd700;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.03); }
        }

        /* Error banner */
        .error-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff5050;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 18px;
            display: none;
            z-index: 100;
        }

        .error-banner.show {
            display: block;
        }

        /* Speaker button for TTS */
        .speaker-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(20px, 5vmin, 36px);
            cursor: pointer;
            display: none;
        }

        .speaker-btn.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .display-area {
            position: relative;
        }

        /* Spelling Bee Game UI */
        .difficulty-selector {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-selector.visible {
            display: flex;
        }

        .difficulty-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #6495ed;
            background: white;
            color: #6495ed;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-btn:active, .difficulty-btn.selected {
            background: #6495ed;
            color: white;
            transform: scale(0.95);
        }

        .game-controls {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-controls.visible {
            display: flex;
        }

        .game-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #32cd32;
            background: white;
            color: #32cd32;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-btn:active {
            background: #32cd32;
            color: white;
            transform: scale(0.95);
        }

        .game-btn.repeat {
            border-color: #ffa500;
            color: #ffa500;
        }

        .game-btn.repeat:active {
            background: #ffa500;
        }

        .spelling-letters {
            display: flex;
            flex-wrap: wrap;
            gap: 1vmin;
            justify-content: center;
            margin-top: 2vmin;
            font-size: clamp(20px, 6vmin, 40px);
        }

        .spelling-letter {
            min-width: clamp(30px, 6vmin, 50px);
            min-height: clamp(30px, 6vmin, 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ccc;
            border-radius: 10px;
            background: #f5f5f5;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .spelling-letter.correct {
            background: #32cd32;
            color: white;
            border-color: #32cd32;
            animation: correctPop 0.3s ease;
        }

        .spelling-letter.incorrect {
            background: #ff5050;
            color: white;
            border-color: #ff5050;
            animation: shake 0.3s ease;
        }

        @keyframes correctPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        /* === BALLOON LETTER GAME === */
        .balloon-screen {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #5db8e8 0%, #93d4f0 35%, #cceeff 70%, #e8f7ff 100%);
            flex-direction: column;
            overflow: hidden;
            z-index: 10;
        }

        .balloon-screen.active {
            display: flex;
        }

        .balloon-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2vmin 4vmin;
            background: rgba(255,255,255,0.65);
            backdrop-filter: blur(6px);
            flex-shrink: 0;
        }

        .balloon-score-display {
            background: white;
            border-radius: 20px;
            padding: 1.5vmin 4vmin;
            font-size: clamp(22px, 5vmin, 44px);
            font-weight: bold;
            color: #f39c12;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 1vmin;
        }

        .balloon-score-display.score-pop {
            animation: scorePop 0.3s ease;
        }

        @keyframes scorePop {
            0%   { transform: scale(1); }
            50%  { transform: scale(1.45); }
            100% { transform: scale(1); }
        }

        .balloon-mic-status {
            font-size: clamp(24px, 6vmin, 48px);
            width: clamp(44px, 10vmin, 80px);
            text-align: center;
        }

        .balloon-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Cloud decorations */
        .balloon-area::before,
        .balloon-area::after {
            content: 'â˜ï¸';
            position: absolute;
            font-size: clamp(40px, 10vmin, 80px);
            opacity: 0.4;
            pointer-events: none;
        }
        .balloon-area::before { top: 10%; left: 5%; }
        .balloon-area::after  { top: 25%; right: 3%; }

        .balloon {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transform: translateX(-50%);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            z-index: 2;
            user-select: none;
        }

        .balloon-body {
            width: clamp(80px, 19vmin, 155px);
            height: clamp(96px, 23vmin, 186px);
            border-radius: 50% 50% 50% 50% / 44% 44% 56% 56%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(38px, 9.5vmin, 82px);
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            box-shadow:
                inset -8px -10px 22px rgba(0,0,0,0.13),
                inset 7px 7px 18px rgba(255,255,255,0.45),
                3px 6px 14px rgba(0,0,0,0.22);
            position: relative;
        }

        /* Shine highlight */
        .balloon-body::after {
            content: '';
            position: absolute;
            top: 12%; left: 17%;
            width: 28%; height: 33%;
            background: rgba(255,255,255,0.42);
            border-radius: 50%;
            transform: rotate(-30deg);
        }

        .balloon-knot {
            width: 12px;
            height: 14px;
            border-radius: 0 0 50% 50%;
            margin-top: -2px;
        }

        .balloon-string {
            width: 2px;
            height: clamp(22px, 5vmin, 44px);
            background: rgba(60,60,60,0.45);
        }

        .balloon.popping {
            animation: balloonPop 0.38s ease-out forwards;
            pointer-events: none;
        }

        @keyframes balloonPop {
            0%   { transform: translateX(-50%) scale(1);    opacity: 1; }
            25%  { transform: translateX(-50%) scale(1.38); opacity: 1; }
            60%  { transform: translateX(-50%) scale(0.55); opacity: 0.55; }
            100% { transform: translateX(-50%) scale(0);    opacity: 0; }
        }

        .balloon-hint {
            text-align: center;
            font-size: clamp(16px, 4vmin, 30px);
            font-weight: bold;
            color: #334;
            padding: 2vmin 4vmin;
            background: rgba(255,255,255,0.65);
            backdrop-filter: blur(4px);
            flex-shrink: 0;
        }

        .balloon-celebration {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(70px, 22vmin, 160px);
            animation: celebrationBurst 0.9s ease-out forwards;
            pointer-events: none;
            z-index: 30;
            white-space: nowrap;
        }

        @keyframes celebrationBurst {
            0%   { transform: translate(-50%, -50%) scale(0);   opacity: 1; }
            40%  { transform: translate(-50%, -50%) scale(1.35); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.1); opacity: 0; }
        }

        .mode-button.balloons { background-color: #ff9f43; }
    </style>
</head>
<body>
    <div id="errorBanner" class="error-banner"></div>

    <!-- Mode Selection Screen -->
    <div id="modeScreen" class="mode-screen">
        <div class="mode-title" id="modeTitle">×‘×—×¨ ××©×—×§</div>
        <div class="mode-buttons">
            <button class="mode-button free-speech" onclick="startMode('free-speech')">
                <span class="icon">ğŸ¤</span>
                <span id="freeSpeechLabel">×“×™×‘×•×¨ ×—×•×¤×©×™</span>
            </button>
            <button class="mode-button spelling" onclick="startMode('spelling')">
                <span class="icon">ğŸ“</span>
                <span id="spellingLabel">××™×•×ª</span>
            </button>
            <button class="mode-button translation" onclick="startMode('translation')">
                <span class="icon">ğŸŒ</span>
                <span id="translationLabel">×ª×¨×’×•×</span>
            </button>
            <button class="mode-button echo" onclick="startMode('echo')">
                <span class="icon">ğŸ”„</span>
                <span id="echoLabel">×—×™×§×•×™</span>
            </button>
            <button class="mode-button balloons" onclick="startMode('balloons')">
                <span class="icon">ğŸˆ</span>
                <span id="balloonsLabel">×‘×œ×•× ×™× - ××•×ª×™×•×ª</span>
            </button>
        </div>
    </div>

    <!-- Free Speech Game Screen -->
    <div id="gameScreen" class="game-screen">
        <div class="top-bar">
            <button class="back-button" onclick="goBack()">â† ×—×–×¨×”</button>
            <div class="lang-toggle">
                <button class="lang-btn active" id="btnHebrew" onclick="setLanguage('hebrew')">×¢×‘×¨×™×ª</button>
                <button class="lang-btn" id="btnEnglish" onclick="setLanguage('english')">English</button>
            </div>
        </div>

        <!-- Difficulty Selector (for Spelling mode) -->
        <div id="difficultySelector" class="difficulty-selector">
            <button class="difficulty-btn" data-difficulty="easy">ğŸŸ¢ Easy / ×§×œ</button>
            <button class="difficulty-btn" data-difficulty="medium">ğŸŸ¡ Medium / ×‘×™× ×•× ×™</button>
            <button class="difficulty-btn" data-difficulty="hard">ğŸ”´ Hard / ×§×©×”</button>
        </div>

        <div class="display-area">
            <button id="speakerBtn" class="speaker-btn" onclick="handleSpeakerClick()">ğŸ”Š</button>
            <div id="displayText" class="display-text text-blue">×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!</div>
            <div id="spellingLetters" class="spelling-letters"></div>
        </div>

        <!-- Game Controls (for Spelling/Translation modes) -->
        <div id="gameControls" class="game-controls">
            <button class="game-btn repeat" onclick="repeatWord()">ğŸ” Repeat / ×—×–×•×¨</button>
            <button class="game-btn" onclick="nextWord()">â¡ï¸ Next / ×”×‘×</button>
        </div>

        <div class="button-area">
            <button id="mainButton" class="big-button button-ready">×œ×—×¥ ×œ×“×‘×¨!</button>
        </div>
    </div>

    <!-- Balloon Letter Game Screen -->
    <div id="balloonScreen" class="balloon-screen">
        <div class="balloon-top-bar">
            <button class="back-button" onclick="exitBalloonGame()">â† ×—×–×¨×”</button>
            <div id="balloonScoreDisplay" class="balloon-score-display">
                â­ <span id="balloonScoreNum">0</span>
            </div>
            <div id="balloonMicStatus" class="balloon-mic-status">ğŸ¤</div>
        </div>
        <div id="balloonArea" class="balloon-area">
            <!-- Balloons are inserted dynamically -->
        </div>
        <div class="balloon-hint" id="balloonHint">×××•×¨ ××ª ×©× ×”××•×ª! (×”×§×© ×¢×œ ×‘×œ×•×Ÿ ×œ×©××•×¢)</div>
    </div>

    <script>
        // ===========================================
        // PWA + INSTALL / FULLSCREEN
        // ===========================================

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('Service worker registered');
            }).catch(err => {
                console.log('Service worker registration skipped:', err.message);
            });
        }

        // Detect if running inside the Android APK
        const isAndroidApp = typeof AndroidBridge !== 'undefined' && AndroidBridge.isAndroidApp && AndroidBridge.isAndroidApp();

        // ===========================================
        // LETTER NAMES FOR SPELLING
        // ===========================================
        const HEBREW_LETTER_NAMES = {
            '×': '×Ö¸×œÖ¶×£', '×‘': '×‘ÖµÖ¼×™×ª', '×’': '×’Ö´Ö¼×™×Ö¶×œ', '×“': '×“Ö¸Ö¼×œÖ¶×ª', '×”': '×”Öµ×',
            '×•': '×•Ö¸×•', '×–': '×–Ö·×™Ö´×Ÿ', '×—': '×—Öµ×™×ª', '×˜': '×˜Öµ×™×ª', '×™': '×™×•Ö¹×“',
            '×›': '×›Ö¸Ö¼×£', '×š': '×›Ö¸Ö¼×£ ×¡×•Ö¹×¤Ö´×™×ª', '×œ': '×œÖ¸×Ö¶×“', '×': '×Öµ×', '×': '×Öµ× ×¡×•Ö¹×¤Ö´×™×ª',
            '× ': '× ×•Ö¼×Ÿ', '×Ÿ': '× ×•Ö¼×Ÿ ×¡×•Ö¹×¤Ö´×™×ª', '×¡': '×¡Ö¸×Ö¶×š', '×¢': '×¢Ö·×™Ö´×Ÿ', '×¤': '×¤ÖµÖ¼×',
            '×£': '×¤ÖµÖ¼× ×¡×•Ö¹×¤Ö´×™×ª', '×¦': '×¦Ö¸×“Ö´×™', '×¥': '×¦Ö¸×“Ö´×™ ×¡×•Ö¹×¤Ö´×™×ª', '×§': '×§×•Ö¹×£',
            '×¨': '×¨Öµ×™×©×', '×©': '×©Ö´××™×Ÿ', '×ª': '×ªÖ¸Ö¼×•'
        };

        // ===========================================
        // LANGUAGE CONFIGURATION
        // ===========================================
        const LANGUAGES = {
            hebrew: {
                code: 'he-IL',
                dir: 'rtl',
                text: {
                    SELECT_MODE: '×‘×—×¨ ××©×—×§',
                    FREE_SPEECH: '×“×™×‘×•×¨ ×—×•×¤×©×™',
                    SPELLING: '××™×•×ª',
                    TRANSLATION: '×ª×¨×’×•×',
                    ECHO: '×—×™×§×•×™',
                    TRANSLATING: '××ª×¨×’×...',
                    TRANSLATE_TO: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª ×œ×ª×¨×’×•× ×œ×× ×’×œ×™×ª',
                    TRANSLATION_ERROR: '×©×’×™××ª ×ª×¨×’×•×',
                    BACK: 'â† ×—×–×¨×”',
                    TAP_TO_SPEAK: '×œ×—×¥ ×œ×“×‘×¨!',
                    RECORDING: '××§×œ×™×˜... (×œ×—×¥ ×œ×¢×¦×™×¨×”)',
                    PROCESSING: '××¢×‘×“...',
                    LISTENING: '××§×©×™×‘...',
                    THINKING: '×—×•×©×‘...',
                    SAY_SOMETHING: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!',
                    NOT_UNDERSTOOD: '×œ× ×”×‘× ×ª×™',
                    NETWORK_ERROR: '×©×’×™××ª ×¨×©×ª',
                    NOT_SUPPORTED: '×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×§×•×œ',
                    NEED_PERMISSION: '× ×“×¨×©×ª ×”×¨×©××ª ××™×§×¨×•×¤×•×Ÿ',
                    BALLOONS: '×‘×œ×•× ×™× - ××•×ª×™×•×ª'
                }
            },
            english: {
                code: 'en-US',
                dir: 'ltr',
                text: {
                    SELECT_MODE: 'Select Game',
                    FREE_SPEECH: 'Free Speech',
                    SPELLING: 'Spelling',
                    TRANSLATION: 'Translation',
                    ECHO: 'Echo Practice',
                    TRANSLATING: 'Translating...',
                    TRANSLATE_TO: 'Say something in English to translate to Hebrew',
                    TRANSLATION_ERROR: 'Translation error',
                    BACK: 'â† Back',
                    TAP_TO_SPEAK: 'Tap to Speak!',
                    RECORDING: 'Recording... (tap to stop)',
                    PROCESSING: 'Processing...',
                    LISTENING: 'Listening...',
                    THINKING: 'Thinking...',
                    SAY_SOMETHING: 'Say something in English!',
                    NOT_UNDERSTOOD: "Didn't understand",
                    NETWORK_ERROR: 'Network error',
                    NOT_SUPPORTED: 'Browser does not support speech recognition',
                    NEED_PERMISSION: 'Microphone permission required',
                    BALLOONS: 'Letter Balloons'
                }
            }
        };

        // ===========================================
        // VOICE INSTRUCTIONS (spoken guidance for kids)
        // ===========================================
        const VOICE_INSTRUCTIONS = {
            hebrew: {
                'listen':    '×”×§×©×‘!',
                'your-turn': '×¢×›×©×™×• ××ª×”!',
                'spell-it':  '××™×™×ª ××ª ×”××™×œ×”!',
                'great':     '××¢×•×œ×”!',
                'correct':   '× ×›×•×Ÿ!',
                'try-again': '× ×¡×” ×©×•×‘!'
            },
            english: {
                'listen':    'Listen!',
                'your-turn': 'Your turn!',
                'spell-it':  'Spell the word!',
                'great':     'Great job!',
                'correct':   'Correct!',
                'try-again': 'Try again!'
            }
        };

        function speakInstruction(key, onComplete = null) {
            const text = VOICE_INSTRUCTIONS[currentLang][key];
            speakText(text, onComplete);
        }

        // ===========================================
        // STATE
        // ===========================================
        let currentLang = 'hebrew';
        let currentMode = null;
        let state = 'ready';
        let recognition = null;
        let recordingTimeout = null;
        let isRecognitionActive = false;
        let lastRecognizedText = '';
        let isSpeaking = false;

        // Spelling Bee Game State
        let wordsData = null;  // Loaded from words.json
        let spellingGame = {
            difficulty: null,
            currentWord: null,
            targetWord: null,
            userSpelling: [],
            wordList: []
        };

        // Echo Practice Game State
        let echoGame = {
            difficulty: null,
            currentWord: null,
            wordList: []
        };

        const MAX_RECORDING_TIME = 10000;

        // Load words.json on startup
        fetch('words.json')
            .then(response => response.json())
            .then(data => {
                wordsData = data;
                console.log('Words loaded:', wordsData);
            })
            .catch(error => console.error('Failed to load words.json:', error));

        function getEmoji(word) {
            if (!wordsData || !wordsData.emoji || !word) return '';
            return wordsData.emoji[word.trim()] || wordsData.emoji[word.trim().toLowerCase()] || '';
        }

        function emojiHtml(word) {
            const emoji = getEmoji(word);
            if (!emoji) return '';
            return `<span class="emoji-pop">${emoji}</span>`;
        }

        // ===========================================
        // ELEMENTS
        // ===========================================
        const modeScreen = document.getElementById('modeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const modeTitle = document.getElementById('modeTitle');
        const freeSpeechLabel = document.getElementById('freeSpeechLabel');
        const spellingLabel = document.getElementById('spellingLabel');
        const translationLabel = document.getElementById('translationLabel');
        const echoLabel = document.getElementById('echoLabel');
        const displayText = document.getElementById('displayText');
        const mainButton = document.getElementById('mainButton');
        const errorBanner = document.getElementById('errorBanner');
        const btnHebrew = document.getElementById('btnHebrew');
        const btnEnglish = document.getElementById('btnEnglish');
        const speakerBtn = document.getElementById('speakerBtn');
        const backButton = document.querySelector('.back-button');
        const difficultySelector = document.getElementById('difficultySelector');
        const gameControls = document.getElementById('gameControls');
        const spellingLetters = document.getElementById('spellingLetters');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');

        // ===========================================
        // TEXT-TO-SPEECH
        // ===========================================
        const synth = window.speechSynthesis;

        // Use native Android TTS when running inside the APK
        const useNativeTts = isAndroidApp && typeof AndroidBridge.speak === 'function';

        // Estimate speech duration for native TTS (no onend callback available)
        function estimateSpeechDuration(text, rate = 0.8) {
            // ~100ms per character at normal rate, adjusted for speech rate
            return Math.max(800, (text.length * 100) / rate + 500);
        }

        function nativeSpeak(text, langCode, onComplete = null) {
            AndroidBridge.speak(text, langCode);
            if (onComplete) {
                setTimeout(onComplete, estimateSpeechDuration(text));
            }
        }

        function stopTts() {
            if (useNativeTts) {
                AndroidBridge.stopSpeaking();
            } else if (synth) {
                synth.cancel();
            }
        }

        function speakText(text = null, onComplete = null) {
            const textToSpeak = text || lastRecognizedText;
            if (!textToSpeak) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();
            setSpeaking(true);
            const langCode = LANGUAGES[currentLang].code;

            const done = () => {
                setSpeaking(false);
                if (onComplete) onComplete();
            };

            if (useNativeTts) {
                nativeSpeak(textToSpeak, langCode, done);
                return;
            }

            if (!synth) { done(); return; }

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = langCode;
            utterance.rate = 0.8;
            utterance.onend = done;
            utterance.onerror = done;
            synth.speak(utterance);
        }

        // Handle speaker button click - speaks in correct language based on mode
        function handleSpeakerClick() {
            if (!lastRecognizedText) return;

            if (currentMode === 'translation') {
                // In translation mode, lastRecognizedText is in the TARGET language
                const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';
                speakInLanguage(lastRecognizedText, targetLangCode);
            } else {
                speakText();
            }
        }

        // ===========================================
        // TRANSLATION API
        // ===========================================
        async function translateText(text, fromLang, toLang) {
            // Use MyMemory free translation API
            const langPair = `${fromLang}|${toLang}`;
            const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${langPair}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.responseStatus === 200 && data.responseData) {
                    return data.responseData.translatedText;
                } else {
                    console.error('Translation API error:', data);
                    return null;
                }
            } catch (error) {
                console.error('Translation fetch error:', error);
                return null;
            }
        }

        // Speak text in a specific language (not necessarily current language)
        function speakInLanguage(text, langCode, onComplete = null) {
            if (!text) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();
            setSpeaking(true);

            const done = () => {
                setSpeaking(false);
                if (onComplete) onComplete();
            };

            if (useNativeTts) {
                nativeSpeak(text, langCode, done);
                return;
            }

            if (!synth) { done(); return; }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.8;
            utterance.onend = done;
            utterance.onerror = done;
            synth.speak(utterance);
        }

        // ===========================================
        // SPELLING BEE GAME FUNCTIONS
        // ===========================================
        function selectDifficulty(difficulty) {
            if (!wordsData) {
                showError('Word list not loaded yet');
                return;
            }

            if (currentMode === 'spelling') {
                // Spelling Bee mode
                spellingGame.difficulty = difficulty;
                spellingGame.wordList = wordsData.spelling[currentLang][difficulty] || [];
                
                if (spellingGame.wordList.length === 0) {
                    showError('No words available for this difficulty');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextWord();
            } else if (currentMode === 'echo') {
                // Echo Practice mode
                echoGame.difficulty = difficulty;
                const echoWords = wordsData.echo && wordsData.echo[currentLang];
                echoGame.wordList = (echoWords && echoWords[difficulty]) || [];
                
                console.log('Echo mode - difficulty:', difficulty, 'words:', echoGame.wordList);
                
                if (echoGame.wordList.length === 0) {
                    showError('No echo words for this level. Try another.');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextEchoWord();
            }
        }

        // ECHO PRACTICE GAME FUNCTIONS
        // ===========================================
        function nextEchoWord() {
            if (!echoGame.wordList || echoGame.wordList.length === 0) {
                showError('No words available');
                return;
            }

            // Pick random word
            const randomIndex = Math.floor(Math.random() * echoGame.wordList.length);
            echoGame.currentWord = echoGame.wordList[randomIndex];

            // Show listening prompt and lock button during TTS sequence
            mainButton.style.display = '';
            displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘!' : 'Listen!';
            displayText.className = 'display-text text-purple';

            // Chain: "Listen!" â†’ word â†’ emoji + "Your turn!" â†’ unlock mic
            speakInstruction('listen', () => {
                speakText(echoGame.currentWord, () => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Your turn! Tap the microphone`;
                    displayText.className = 'display-text text-purple';
                    speakInstruction('your-turn', () => {
                        setState('ready');
                    });
                });
            });
        }

        function handleEchoRecordingComplete(text) {
            if (!text || text.trim() === '') {
                showError(currentLang === 'hebrew' ? '×œ× ×”×‘× ×ª×™, × ×¡×” ×©×•×‘' : "I didn't understand, try again");
                setState('ready');
                return;
            }

            // Show what user said and encourage with emoji
            const echoEmoji = emojiHtml(echoGame.currentWord);
            displayText.innerHTML = currentLang === 'hebrew'
                ? `${echoEmoji}×××¨×ª: <b>${text}</b><br>××¢×•×œ×”! ğŸ‘`
                : `${echoEmoji}You said: <b>${text}</b><br>Great! ğŸ‘`;
            displayText.className = 'display-text text-purple';

            // Voice: "Great!" then auto-advance to next word
            speakInstruction('great', () => {
                setTimeout(nextEchoWord, 1000);
            });
        }

        function nextWord() {
            if (currentMode === 'echo') {
                // Echo mode - go to next word
                nextEchoWord();
            } else if (currentMode === 'spelling') {
                // Spelling mode - pick next spelling word
                if (!spellingGame.wordList || spellingGame.wordList.length === 0) {
                    showError('No words available');
                    return;
                }

                // Pick random word
                const randomIndex = Math.floor(Math.random() * spellingGame.wordList.length);
                spellingGame.targetWord = spellingGame.wordList[randomIndex];
                spellingGame.currentWord = spellingGame.targetWord;
                spellingGame.userSpelling = [];

                // Reset spelling letters display
                updateSpellingDisplay();

                // Show listening prompt and lock button during TTS sequence
                displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘!' : 'Listen!';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = '';

                // Chain: "Listen!" â†’ word â†’ "Spell the word!" â†’ unlock mic
                speakInstruction('listen', () => {
                    speakText(spellingGame.targetWord, () => {
                        displayText.textContent = currentLang === 'hebrew' ? '××™×™×ª ××ª ×”××™×œ×”!' : 'Spell the word!';
                        displayText.className = 'display-text text-green';
                        speakInstruction('spell-it', () => {
                            setState('ready');
                        });
                    });
                });
            }
        }

        function repeatWord() {
            if (currentMode === 'echo') {
                // Echo mode - repeat with voice guidance
                if (!echoGame.currentWord) return;

                displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘!' : 'Listen!';
                displayText.className = 'display-text text-purple';

                // Chain: word â†’ "Your turn!" â†’ unlock mic
                speakText(echoGame.currentWord, () => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Your turn! Tap the microphone`;
                    speakInstruction('your-turn', () => {
                        setState('ready');
                    });
                });
            } else if (currentMode === 'spelling') {
                // Spelling mode - repeat with voice guidance
                if (!spellingGame.targetWord) return;

                displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘!' : 'Listen!';
                displayText.className = 'display-text text-blue';

                // Chain: word â†’ "Spell the word!" â†’ unlock mic
                speakText(spellingGame.targetWord, () => {
                    displayText.textContent = currentLang === 'hebrew' ? '××™×™×ª ××ª ×”××™×œ×”!' : 'Spell the word!';
                    displayText.className = 'display-text text-green';
                    speakInstruction('spell-it', () => {
                        setState('ready');
                    });
                });
            }
        }

        function updateSpellingDisplay() {
            if (!spellingGame.targetWord) {
                spellingLetters.innerHTML = '';
                return;
            }

            const letters = [...spellingGame.targetWord];
            spellingLetters.innerHTML = letters.map((letter, index) => {
                let className = 'spelling-letter';
                let content = '_';
                
                if (spellingGame.userSpelling[index]) {
                    content = spellingGame.userSpelling[index].char;
                    className += spellingGame.userSpelling[index].correct ? ' correct' : ' incorrect';
                }
                
                return `<div class="${className}">${content}</div>`;
            }).join('');
        }

        function checkSpelling(spokenText) {
            if (!spellingGame.targetWord) return;
            
            // Normalize the spoken text
            const normalized = spokenText.trim().toLowerCase();
            const targetLetters = [...spellingGame.targetWord.toLowerCase()];
            
            // Track which positions are already filled
            const filledPositions = new Set(
                Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k])
                    .map(k => parseInt(k))
            );
            
            // Check if user spoke a single letter
            let matchedLetterIndex = -1;
            
            // For Hebrew, check against letter names
            if (currentLang === 'hebrew') {
                for (const [letter, name] of Object.entries(HEBREW_LETTER_NAMES)) {
                    if (normalized.includes(name.toLowerCase()) || normalized.includes(letter)) {
                        // Find first unfilled position for this letter
                        for (let i = 0; i < targetLetters.length; i++) {
                            if (targetLetters[i] === letter.toLowerCase() && !filledPositions.has(i)) {
                                matchedLetterIndex = i;
                                spellingGame.userSpelling[i] = { char: letter, correct: true };
                                break;
                            }
                        }
                        break;
                    }
                }
            } else {
                // For English, check if it's a single letter
                if (normalized.length === 1 && /[a-z]/.test(normalized)) {
                    for (let i = 0; i < targetLetters.length; i++) {
                        if (targetLetters[i] === normalized && !filledPositions.has(i)) {
                            matchedLetterIndex = i;
                            spellingGame.userSpelling[i] = { char: normalized, correct: true };
                            break;
                        }
                    }
                }
            }
            
            if (matchedLetterIndex >= 0) {
                // Correct letter!
                updateSpellingDisplay();

                // Check if word is complete (count filled positions)
                const filledCount = Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k] && spellingGame.userSpelling[k].correct)
                    .length;

                if (filledCount === targetLetters.length) {
                    // Word completed successfully! Show emoji celebration
                    const spellingEmoji = emojiHtml(spellingGame.targetWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${spellingEmoji}ğŸ‰ ××¦×•×™×Ÿ! ××™×œ×” × ×›×•× ×”!`
                        : `${spellingEmoji}ğŸ‰ Excellent! Correct!`;
                    displayText.className = 'display-text text-green';
                    speakInstruction('great', () => {
                        setTimeout(nextWord, 1500);
                    });
                } else {
                    // Continue spelling - voice feedback
                    displayText.textContent = currentLang === 'hebrew' ? '× ×›×•×Ÿ! âœ“ ×”××©×š...' : 'Correct! âœ“ Continue...';
                    displayText.className = 'display-text text-green';
                    speakInstruction('correct');
                }
            } else {
                // Incorrect or unrecognized - voice feedback
                displayText.textContent = currentLang === 'hebrew' ? 'âŒ × ×¡×” ×©×•×‘' : 'âŒ Try again';
                displayText.className = 'display-text text-red';
                speakInstruction('try-again');
            }
        }

        // ===========================================
        // LANGUAGE FUNCTIONS
        // ===========================================
        function getText(key) {
            return LANGUAGES[currentLang].text[key];
        }

        function setLanguage(lang) {
            currentLang = lang;
            const langConfig = LANGUAGES[lang];

            // Update document direction
            document.documentElement.lang = lang === 'hebrew' ? 'he' : 'en';
            document.documentElement.dir = langConfig.dir;

            // Update toggle buttons
            btnHebrew.classList.toggle('active', lang === 'hebrew');
            btnEnglish.classList.toggle('active', lang === 'english');

            // Update UI text
            updateUIText();

            // Reinitialize speech recognition with new language
            initSpeechRecognition();

            // Reset state
            if (state !== 'ready') {
                stopRecording();
            }
            setState('ready');
        }

        function updateUIText() {
            // Mode screen
            modeTitle.textContent = getText('SELECT_MODE');
            freeSpeechLabel.textContent = getText('FREE_SPEECH');
            spellingLabel.textContent = getText('SPELLING');
            translationLabel.textContent = getText('TRANSLATION');
            echoLabel.textContent = getText('ECHO');
            document.getElementById('balloonsLabel').textContent = getText('BALLOONS');

            // Game screen
            backButton.textContent = getText('BACK');

            // Update based on current state
            if (state === 'ready') {
                if (currentMode === 'translation') {
                    displayText.textContent = getText('TRANSLATE_TO');
                } else {
                    displayText.textContent = getText('SAY_SOMETHING');
                }
                mainButton.textContent = getText('TAP_TO_SPEAK');
            }
        }

        // ===========================================
        // MODE NAVIGATION
        // ===========================================
        function startMode(mode) {
            if (mode === 'balloons') {
                currentMode = mode;
                startBalloonGame();
                return;
            }
            currentMode = mode;
            modeScreen.classList.add('hidden');
            gameScreen.classList.add('active');
            
            // Reset UI elements
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            
            // Mode-specific initialization
            if (mode === 'spelling') {
                // Show difficulty selector for spelling mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = 'none';
                
                // Reset spelling game state
                spellingGame.difficulty = null;
                spellingGame.currentWord = null;
                spellingGame.targetWord = null;
                spellingGame.userSpelling = [];
                spellingGame.wordList = [];
            } else if (mode === 'echo') {
                // Show difficulty selector for echo mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-purple';
                mainButton.style.display = 'none';
                
                // Reset echo game state
                echoGame.difficulty = null;
                echoGame.currentWord = null;
                echoGame.wordList = [];
                
                // Check if wordsData is loaded
                if (!wordsData || !wordsData.echo) {
                    displayText.textContent = currentLang === 'hebrew' ? '×˜×•×¢×Ÿ ××™×œ×™×...' : 'Loading words...';
                }
            } else {
                // For free-speech and translation modes, show main button
                mainButton.style.display = '';
                setState('ready');
            }
        }

        function goBack() {
            if (isRecognitionActive) {
                stopRecording();
            }
            stopTts();

            currentMode = null;
            lastRecognizedText = '';
            speakerBtn.classList.remove('visible');
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            mainButton.style.display = '';
            gameScreen.classList.remove('active');
            modeScreen.classList.remove('hidden');
        }

        // ===========================================
        // SPEECH RECOGNITION
        // ===========================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        function initSpeechRecognition() {
            if (!SpeechRecognition) {
                showError(getText('NOT_SUPPORTED') + ' - Use Chrome');
                return;
            }

            // Stop existing recognition
            if (recognition) {
                try {
                    recognition.abort();
                } catch (e) {}
            }

            recognition = new SpeechRecognition();
            recognition.lang = LANGUAGES[currentLang].code;
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log('Recognition started');
                isRecognitionActive = true;
                setState('recording');

                recordingTimeout = setTimeout(() => {
                    console.log('Auto-stopping after timeout');
                    stopRecording();
                }, MAX_RECORDING_TIME);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    console.log('Final:', finalTranscript);
                    clearRecordingTimeout();
                    showResult(finalTranscript);
                } else if (interimTranscript) {
                    console.log('Interim:', interimTranscript);
                    displayText.textContent = interimTranscript;
                    displayText.className = 'display-text text-black';
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                clearRecordingTimeout();
                isRecognitionActive = false;

                switch (event.error) {
                    case 'not-allowed':
                        showError(getText('NEED_PERMISSION'));
                        showResult(getText('NEED_PERMISSION'));
                        break;
                    case 'network':
                        showResult(getText('NETWORK_ERROR'));
                        break;
                    case 'no-speech':
                        showResult(getText('NOT_UNDERSTOOD'));
                        break;
                    case 'aborted':
                        setState('ready');
                        break;
                    default:
                        showResult(getText('NOT_UNDERSTOOD'));
                }
            };

            recognition.onend = () => {
                console.log('Recognition ended');
                clearRecordingTimeout();
                isRecognitionActive = false;

                if (state === 'recording') {
                    showResult(getText('NOT_UNDERSTOOD'));
                }
            };
        }

        function clearRecordingTimeout() {
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
        }

        // ===========================================
        // STATE MANAGEMENT
        // ===========================================
        function setState(newState) {
            state = newState;

            switch (state) {
                case 'ready':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    // Show appropriate prompt based on mode
                    if (currentMode === 'translation') {
                        displayText.textContent = getText('TRANSLATE_TO');
                    } else {
                        displayText.textContent = getText('SAY_SOMETHING');
                    }
                    displayText.className = 'display-text text-blue';
                    break;

                case 'recording':
                    mainButton.textContent = getText('RECORDING');
                    mainButton.className = 'big-button button-recording';
                    displayText.textContent = getText('LISTENING');
                    displayText.className = 'display-text text-red';
                    speakerBtn.classList.remove('visible');
                    break;

                case 'processing':
                    mainButton.textContent = getText('PROCESSING');
                    mainButton.className = 'big-button button-processing';
                    displayText.textContent = getText('THINKING');
                    displayText.className = 'display-text text-yellow';
                    break;

                case 'showing':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    break;
            }
        }

        function showResult(text) {
            const isError = text === getText('NOT_UNDERSTOOD') ||
                           text === getText('NETWORK_ERROR') ||
                           text === getText('NEED_PERMISSION');

            // Handle translation mode separately
            if (currentMode === 'translation' && !isError) {
                handleTranslationResult(text);
                return;
            }

            // Handle spelling mode game separately
            if (currentMode === 'spelling' && !isError && spellingGame.targetWord) {
                checkSpelling(text);
                // Stay in ready state to continue spelling
                setState('ready');
                return;
            }

            // Handle echo mode - encourage and play next word
            if (currentMode === 'echo' && !isError) {
                handleEchoRecordingComplete(text);
                return;
            }

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';
            const resultEmoji = isError ? '' : emojiHtml(text);
            displayText.innerHTML = resultEmoji ? `${resultEmoji}${text}` : text;
            displayText.className = 'display-text text-black';

            // Store for TTS and show speaker button
            if (!isError) {
                lastRecognizedText = text;
                speakerBtn.classList.add('visible');
            } else {
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');
            }
        }

        async function handleTranslationResult(spokenText) {
            // Show translating state
            state = 'processing';
            mainButton.textContent = getText('PROCESSING');
            mainButton.className = 'big-button button-processing';
            displayText.textContent = getText('TRANSLATING');
            displayText.className = 'display-text text-yellow';

            // Determine source and target languages
            const fromLang = currentLang === 'hebrew' ? 'he' : 'en';
            const toLang = currentLang === 'hebrew' ? 'en' : 'he';
            const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';

            // Translate
            const translation = await translateText(spokenText, fromLang, toLang);

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';

            if (translation) {
                // Show both original and translation with emoji
                const transEmoji = emojiHtml(spokenText) || emojiHtml(translation);
                displayText.innerHTML = `${transEmoji}<div style="font-size: 0.5em; color: #888; margin-bottom: 10px;">${spokenText}</div>${translation}`;
                displayText.className = 'display-text text-black';
                lastRecognizedText = translation;
                speakerBtn.classList.add('visible');

                // Speak the translation in target language
                setTimeout(() => {
                    speakInLanguage(translation, targetLangCode);
                }, 300);
            } else {
                displayText.textContent = getText('TRANSLATION_ERROR');
                displayText.className = 'display-text text-red';
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');
            }
        }

        function showError(message) {
            errorBanner.textContent = message;
            errorBanner.classList.add('show');
            setTimeout(() => {
                errorBanner.classList.remove('show');
            }, 5000);
        }

        // ===========================================
        // RECORDING CONTROL
        // ===========================================
        function startRecording() {
            if (!recognition) {
                showError(getText('NOT_SUPPORTED'));
                return;
            }

            if (isRecognitionActive) {
                console.log('Recognition already active, ignoring start');
                return;
            }

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                isRecognitionActive = false;

                if (e.message && e.message.includes('already')) {
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e2) {
                            showError('Error: ' + e2.message);
                        }
                    }, 200);
                } else {
                    showError('Error: ' + e.message);
                }
            }
        }

        function stopRecording() {
            if (!recognition || !isRecognitionActive) {
                return;
            }

            console.log('Stopping recording');
            clearRecordingTimeout();

            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
        }

        let lastButtonPress = 0;
        function handleButtonClick() {
            if (isSpeaking) return;

            const now = Date.now();
            if (now - lastButtonPress < 400) return;
            lastButtonPress = now;

            if (state === 'recording') {
                stopRecording();
            } else if (state === 'ready' || state === 'showing') {
                startRecording();
            }
        }

        // ===========================================
        // TTS UI LOCK
        // ===========================================
        function setSpeaking(speaking) {
            isSpeaking = speaking;
            if (speaking) {
                mainButton.classList.add('button-speaking');
                mainButton.disabled = true;
            } else {
                mainButton.classList.remove('button-speaking');
                mainButton.disabled = false;
            }
        }

        // ===========================================
        // EVENT LISTENERS
        // ===========================================
        // Single pointerup listener prevents double-fire from click+touchend
        mainButton.addEventListener('pointerup', (e) => {
            e.preventDefault();
            handleButtonClick();
        });

        // Add event listeners for difficulty buttons
        difficultyBtns.forEach((btn) => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const difficulty = e.currentTarget.dataset.difficulty;
                selectDifficulty(difficulty);
            });
        });
        // ===========================================
        // BALLOON LETTER GAME
        // ===========================================

        const BALLOON_COLORS = [
            '#FF5252', '#FF7043', '#FF9800', '#FDD835',
            '#66BB6A', '#26C6DA', '#42A5F5', '#AB47BC',
            '#EC407A', '#26A69A'
        ];

        // 22 Hebrew letters: ttsName has niqqud for clear TTS, matchNames are
        // what the he-IL speech recognizer returns when a child says the name.
        const BALLOON_LETTERS = [
            { letter: '×', ttsName: '×Ö¸×œÖ¶×£',  matchNames: ['××œ×£'] },
            { letter: '×‘', ttsName: '×‘ÖµÖ¼×™×ª',  matchNames: ['×‘×™×ª', '×‘×ª'] },
            { letter: '×’', ttsName: '×’Ö´Ö¼×™×Ö¶×œ', matchNames: ['×’×™××œ', '×’××œ'] },
            { letter: '×“', ttsName: '×“Ö¸Ö¼×œÖ¶×ª',  matchNames: ['×“×œ×ª'] },
            { letter: '×”', ttsName: '×”Öµ×',     matchNames: ['×”×', '×”×”'] },
            { letter: '×•', ttsName: '×•Ö¸×•',     matchNames: ['×•×•', '×•××•', '×•×•×™'] },
            { letter: '×–', ttsName: '×–Ö·×™Ö´×Ÿ',   matchNames: ['×–×™×Ÿ', '×–×™×™×Ÿ'] },
            { letter: '×—', ttsName: '×—Öµ×™×ª',    matchNames: ['×—×™×ª', '×—×ª'] },
            { letter: '×˜', ttsName: '×˜Öµ×™×ª',    matchNames: ['×˜×™×ª', '×˜×ª'] },
            { letter: '×™', ttsName: '×™×•Ö¹×“',    matchNames: ['×™×•×“'] },
            { letter: '×›', ttsName: '×›Ö¸Ö¼×£',    matchNames: ['×›×£'] },
            { letter: '×œ', ttsName: '×œÖ¸×Ö¶×“',   matchNames: ['×œ××“'] },
            { letter: '×', ttsName: '×Öµ×',     matchNames: ['××'] },
            { letter: '× ', ttsName: '× ×•Ö¼×Ÿ',    matchNames: ['× ×•×Ÿ'] },
            { letter: '×¡', ttsName: '×¡Ö¸×Ö¶×š',   matchNames: ['×¡××š'] },
            { letter: '×¢', ttsName: '×¢Ö·×™Ö´×Ÿ',   matchNames: ['×¢×™×Ÿ', '×¢×™×™×Ÿ'] },
            { letter: '×¤', ttsName: '×¤ÖµÖ¼×',    matchNames: ['×¤×', '×¤×”'] },
            { letter: '×¦', ttsName: '×¦Ö¸×“Ö´×™',   matchNames: ['×¦×“×™', '×¦×“'] },
            { letter: '×§', ttsName: '×§×•Ö¹×£',    matchNames: ['×§×•×£'] },
            { letter: '×¨', ttsName: '×¨Öµ×™×©×',   matchNames: ['×¨×™×©'] },
            { letter: '×©', ttsName: '×©Ö´××™×Ÿ',   matchNames: ['×©×™×Ÿ'] },
            { letter: '×ª', ttsName: '×ªÖ¸Ö¼×•',    matchNames: ['×ª×•', '×ª×‘'] },
        ];

        let balloonGame = {
            active: false,
            balloons: [],
            score: 0,
            recognition: null,
            balloonIdCounter: 0,
            animationFrameId: null,
            lastTimestamp: null,
            maxBalloons: 5
        };

        // Lighten a hex color by mixing toward white
        function lightenHex(hex, amount = 60) {
            const r = Math.min(255, parseInt(hex.slice(1, 3), 16) + amount);
            const g = Math.min(255, parseInt(hex.slice(3, 5), 16) + amount);
            const b = Math.min(255, parseInt(hex.slice(5, 7), 16) + amount);
            return `rgb(${r},${g},${b})`;
        }

        function startBalloonGame() {
            modeScreen.classList.add('hidden');
            document.getElementById('balloonScreen').classList.add('active');

            balloonGame.active = true;
            balloonGame.score = 0;
            balloonGame.balloons = [];
            balloonGame.balloonIdCounter = 0;
            balloonGame.lastTimestamp = null;
            document.getElementById('balloonScoreNum').textContent = '0';
            document.getElementById('balloonArea').innerHTML = '';
            document.getElementById('balloonMicStatus').textContent = 'ğŸ¤';

            // Stagger initial balloons so they don't all appear at once
            for (let i = 0; i < balloonGame.maxBalloons; i++) {
                setTimeout(() => { if (balloonGame.active) createBalloon(); }, i * 550);
            }

            balloonGame.animationFrameId = requestAnimationFrame(animateBalloons);
            startBalloonRecognition();
        }

        function exitBalloonGame() {
            balloonGame.active = false;

            if (balloonGame.recognition) {
                try { balloonGame.recognition.abort(); } catch (e) {}
                balloonGame.recognition = null;
            }
            if (balloonGame.animationFrameId) {
                cancelAnimationFrame(balloonGame.animationFrameId);
                balloonGame.animationFrameId = null;
            }

            stopTts();
            document.getElementById('balloonArea').innerHTML = '';
            balloonGame.balloons = [];
            balloonGame.lastTimestamp = null;

            document.getElementById('balloonScreen').classList.remove('active');
            modeScreen.classList.remove('hidden');
        }

        function createBalloon() {
            if (!balloonGame.active) return;
            const area = document.getElementById('balloonArea');
            if (!area) return;

            const letterData = BALLOON_LETTERS[Math.floor(Math.random() * BALLOON_LETTERS.length)];
            const color = BALLOON_COLORS[Math.floor(Math.random() * BALLOON_COLORS.length)];
            const id = ++balloonGame.balloonIdCounter;

            // Random horizontal position, start just below visible area
            const x = 12 + Math.random() * 76;
            const startY = 108;

            const el = document.createElement('div');
            el.className = 'balloon';
            el.dataset.balloonId = id;
            el.style.left = x + '%';
            el.style.top = startY + '%';

            const lightColor = lightenHex(color);
            el.innerHTML = `
                <div class="balloon-body" style="background: radial-gradient(circle at 35% 30%, ${lightColor}, ${color})">
                    ${letterData.letter}
                </div>
                <div class="balloon-knot" style="background: ${color}"></div>
                <div class="balloon-string"></div>
            `;

            area.appendChild(el);

            // Tap balloon â†’ speak its letter name (hint for child)
            el.addEventListener('pointerup', (e) => {
                e.stopPropagation();
                const b = balloonGame.balloons.find(b => b.id === id);
                if (b && !b.popped) {
                    speakInLanguage(b.letterData.ttsName, 'he-IL');
                }
            });

            const balloon = {
                id,
                letter: letterData.letter,
                letterData,
                x,
                y: startY,
                speed: 7 + Math.random() * 7,        // % per second upward
                driftAmp: 1.5 + Math.random() * 2.5, // horizontal oscillation amplitude (%)
                driftFreq: 0.28 + Math.random() * 0.35, // Hz
                driftPhase: Math.random() * Math.PI * 2,
                color,
                element: el,
                popped: false,
                age: 0
            };

            balloonGame.balloons.push(balloon);
            return balloon;
        }

        function animateBalloons(timestamp) {
            if (!balloonGame.active) return;

            if (balloonGame.lastTimestamp === null) balloonGame.lastTimestamp = timestamp;
            const dt = Math.min((timestamp - balloonGame.lastTimestamp) / 1000, 0.1);
            balloonGame.lastTimestamp = timestamp;

            const toRemove = [];

            for (const b of balloonGame.balloons) {
                if (b.popped) continue;

                b.age += dt;
                b.y -= b.speed * dt;

                // Sinusoidal horizontal drift
                const driftX = Math.sin(b.age * b.driftFreq * Math.PI * 2 + b.driftPhase) * b.driftAmp;
                const displayX = Math.max(5, Math.min(93, b.x + driftX));

                b.element.style.left = displayX + '%';
                b.element.style.top = b.y + '%';

                if (b.y < -30) toRemove.push(b);
            }

            for (const b of toRemove) {
                b.element.remove();
                balloonGame.balloons = balloonGame.balloons.filter(x => x.id !== b.id);
                setTimeout(() => { if (balloonGame.active) createBalloon(); }, 400);
            }

            balloonGame.animationFrameId = requestAnimationFrame(animateBalloons);
        }

        function popBalloon(balloon) {
            if (balloon.popped) return;
            balloon.popped = true;

            balloon.element.classList.add('popping');

            // Confirm the letter name back to the child
            speakInLanguage(balloon.letterData.ttsName, 'he-IL');

            balloonGame.score++;
            document.getElementById('balloonScoreNum').textContent = balloonGame.score;

            const scoreDisplay = document.getElementById('balloonScoreDisplay');
            scoreDisplay.classList.remove('score-pop');
            void scoreDisplay.offsetWidth; // force reflow for re-trigger
            scoreDisplay.classList.add('score-pop');

            if (balloonGame.score % 5 === 0) showBalloonCelebration();

            setTimeout(() => {
                balloon.element.remove();
                balloonGame.balloons = balloonGame.balloons.filter(b => b.id !== balloon.id);
                setTimeout(() => { if (balloonGame.active) createBalloon(); }, 350);
            }, 380);
        }

        function matchAndPopBalloon(transcript) {
            const text = transcript.trim();
            if (!text) return false;

            for (const balloon of balloonGame.balloons) {
                if (balloon.popped) continue;
                for (const name of balloon.letterData.matchNames) {
                    if (text.includes(name)) {
                        popBalloon(balloon);
                        return true;
                    }
                }
            }
            return false;
        }

        function showBalloonCelebration() {
            const area = document.getElementById('balloonArea');
            if (!area) return;
            const el = document.createElement('div');
            el.className = 'balloon-celebration';
            el.textContent = 'ğŸ‰';
            area.appendChild(el);
            speakInLanguage('××¢×•×œ×”!', 'he-IL');
            setTimeout(() => el.remove(), 1000);
        }

        function startBalloonRecognition() {
            if (!balloonGame.active) return;
            if (!SpeechRecognition) {
                document.getElementById('balloonMicStatus').textContent = 'âŒ';
                return;
            }

            const recog = new SpeechRecognition();
            recog.lang = 'he-IL'; // always Hebrew â€” balloon mode is alef-bet only
            recog.continuous = false;
            recog.interimResults = true;
            recog.maxAlternatives = 3;
            balloonGame.recognition = recog;

            recog.onstart = () => {
                document.getElementById('balloonMicStatus').textContent = 'ğŸ¤';
            };

            recog.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    for (let j = 0; j < event.results[i].length; j++) {
                        if (matchAndPopBalloon(event.results[i][j].transcript)) return;
                    }
                }
            };

            recog.onerror = (event) => {
                if (event.error === 'aborted') return;
                if (event.error === 'not-allowed') {
                    document.getElementById('balloonMicStatus').textContent = 'ğŸš«';
                    return;
                }
                if (balloonGame.active) {
                    setTimeout(() => { if (balloonGame.active) startBalloonRecognition(); }, 700);
                }
            };

            recog.onend = () => {
                // Keep the mic always open â€” restart immediately
                if (balloonGame.active) {
                    setTimeout(() => { if (balloonGame.active) startBalloonRecognition(); }, 150);
                }
            };

            try {
                recog.start();
            } catch (e) {
                if (balloonGame.active) {
                    setTimeout(() => { if (balloonGame.active) startBalloonRecognition(); }, 600);
                }
            }
        }

        // ===========================================
        // INITIALIZATION
        // ===========================================
        function init() {
            // Request microphone permission
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                        console.log('Microphone permission granted');
                    })
                    .catch(err => {
                        console.log('Microphone permission not yet granted:', err);
                    });
            }

            // Initialize with Hebrew
            setLanguage('hebrew');
            console.log('Hebrew Voice App loaded');
        }

        init();
    </script>
</body>
</html>
