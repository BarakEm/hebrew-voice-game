<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6495ed">
    <title>Hebrew Voice Game</title>

    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            touch-action: manipulation;
        }

        body {
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            padding: 4vmin;
            gap: 3vmin;
            touch-action: manipulation;
        }

        /* Mode Selection Screen */
        .mode-screen {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .mode-title {
            text-align: center;
            font-size: clamp(24px, 8vmin, 60px);
            font-weight: bold;
            color: #6495ed;
            padding: 2vmin 0;
        }

        .mode-buttons {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3vmin;
        }

        .mode-button {
            flex: 1;
            border: none;
            border-radius: 30px;
            font-size: clamp(18px, 5vmin, 40px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 6px 6px 0 rgba(100, 100, 100, 0.4);
            border: 4px solid white;
            transition: transform 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1vmin;
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button .icon {
            font-size: clamp(30px, 10vmin, 80px);
        }

        .mode-button.free-speech { background-color: #32cd32; }
        .mode-button.spelling { background-color: #ff6b6b; }
        .mode-button.translation { background-color: #4ecdc4; }
        .mode-button.echo { background-color: #9b59b6; }
        .mode-button.disabled {
            background-color: #ccc;
            opacity: 0.6;
        }

        /* Game Screen */
        .game-screen {
            display: none;
            flex-direction: column;
            height: 100%;
            gap: 3vmin;
        }

        .game-screen.active {
            display: flex;
        }

        .mode-screen.hidden {
            display: none;
        }

        /* Top bar with back button and language toggle */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2vmin;
        }

        .back-button {
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 15px;
            padding: 2vmin 4vmin;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 rgba(100, 100, 100, 0.3);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .lang-toggle {
            display: flex;
            background: white;
            border-radius: 25px;
            padding: 0.5vmin;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .lang-btn {
            padding: 2vmin 4vmin;
            border: none;
            border-radius: 20px;
            font-size: clamp(14px, 3.5vmin, 24px);
            font-weight: bold;
            cursor: pointer;
            background: transparent;
            color: #666;
            transition: all 0.2s ease;
        }

        .lang-btn.active {
            background: #6495ed;
            color: white;
        }

        /* Button disabled during TTS */
        .button-speaking {
            background-color: #b0b0b0;
            cursor: not-allowed;
        }

        /* Display area */
        .display-area {
            flex: 1;
            background: white;
            border-radius: 30px;
            border: 5px solid #6495ed;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 0;
        }

        .display-text {
            font-size: clamp(24px, 12vmin, 120px);
            font-weight: bold;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        .text-blue { color: #6495ed; }
        .text-red { color: #ff5050; }
        .text-yellow { color: #daa520; }
        .text-black { color: #000; }
        .text-green { color: #32cd32; }
        .text-purple { color: #9b59b6; }

        .emoji-pop {
            font-size: clamp(60px, 20vmin, 180px);
            display: block;
            text-align: center;
            animation: emojiBounce 0.6s ease;
            line-height: 1.2;
        }

        @keyframes emojiBounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.3); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Button area */
        .button-area {
            height: 22vh;
            min-height: 80px;
        }

        .big-button {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 40px;
            font-size: clamp(20px, 6vmin, 48px);
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            outline: none;
            transition: transform 0.1s ease;
            box-shadow: 8px 8px 0 rgba(100, 100, 100, 0.5);
            border: 6px solid white;
        }

        .big-button:active {
            transform: scale(0.98);
        }

        .button-ready { background-color: #32cd32; }
        .button-recording {
            background-color: #ff5050;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        .button-processing {
            background-color: #ffd700;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.03); }
        }

        /* Error banner */
        .error-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff5050;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 18px;
            display: none;
            z-index: 100;
        }

        .error-banner.show {
            display: block;
        }

        /* Speaker button for TTS */
        .speaker-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #6495ed;
            color: white;
            border: none;
            border-radius: 50%;
            width: clamp(40px, 8vmin, 60px);
            height: clamp(40px, 8vmin, 60px);
            font-size: clamp(20px, 5vmin, 36px);
            cursor: pointer;
            display: none;
        }

        .speaker-btn.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .display-area {
            position: relative;
        }

        /* Spelling Bee Game UI */
        .difficulty-selector {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-selector.visible {
            display: flex;
        }

        .difficulty-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #6495ed;
            background: white;
            color: #6495ed;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-btn:active, .difficulty-btn.selected {
            background: #6495ed;
            color: white;
            transform: scale(0.95);
        }

        .game-controls {
            display: none;
            flex-direction: row;
            gap: 2vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-controls.visible {
            display: flex;
        }

        .game-btn {
            padding: 2vmin 4vmin;
            border: 3px solid #32cd32;
            background: white;
            color: #32cd32;
            border-radius: 20px;
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-btn:active {
            background: #32cd32;
            color: white;
            transform: scale(0.95);
        }

        .game-btn.repeat {
            border-color: #ffa500;
            color: #ffa500;
        }

        .game-btn.repeat:active {
            background: #ffa500;
        }

        .spelling-letters {
            display: flex;
            flex-wrap: wrap;
            gap: 1vmin;
            justify-content: center;
            margin-top: 2vmin;
            font-size: clamp(20px, 6vmin, 40px);
        }

        .spelling-letter {
            min-width: clamp(30px, 6vmin, 50px);
            min-height: clamp(30px, 6vmin, 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ccc;
            border-radius: 10px;
            background: #f5f5f5;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .spelling-letter.correct {
            background: #32cd32;
            color: white;
            border-color: #32cd32;
            animation: correctPop 0.3s ease;
        }

        .spelling-letter.incorrect {
            background: #ff5050;
            color: white;
            border-color: #ff5050;
            animation: shake 0.3s ease;
        }

        @keyframes correctPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</head>
<body>
    <div id="errorBanner" class="error-banner"></div>

    <!-- Mode Selection Screen -->
    <div id="modeScreen" class="mode-screen">
        <div class="mode-title" id="modeTitle">×‘×—×¨ ××©×—×§</div>
        <div class="mode-buttons">
            <button class="mode-button free-speech" onclick="startMode('free-speech')">
                <span class="icon">ğŸ¤</span>
                <span id="freeSpeechLabel">×“×™×‘×•×¨ ×—×•×¤×©×™</span>
            </button>
            <button class="mode-button spelling" onclick="startMode('spelling')">
                <span class="icon">ğŸ“</span>
                <span id="spellingLabel">××™×•×ª</span>
            </button>
            <button class="mode-button translation" onclick="startMode('translation')">
                <span class="icon">ğŸŒ</span>
                <span id="translationLabel">×ª×¨×’×•×</span>
            </button>
            <button class="mode-button echo" onclick="startMode('echo')">
                <span class="icon">ğŸ”„</span>
                <span id="echoLabel">×—×™×§×•×™</span>
            </button>
        </div>
    </div>

    <!-- Free Speech Game Screen -->
    <div id="gameScreen" class="game-screen">
        <div class="top-bar">
            <button class="back-button" onclick="goBack()">â† ×—×–×¨×”</button>
            <div class="lang-toggle">
                <button class="lang-btn active" id="btnHebrew" onclick="setLanguage('hebrew')">×¢×‘×¨×™×ª</button>
                <button class="lang-btn" id="btnEnglish" onclick="setLanguage('english')">English</button>
            </div>
        </div>

        <!-- Difficulty Selector (for Spelling mode) -->
        <div id="difficultySelector" class="difficulty-selector">
            <button class="difficulty-btn" data-difficulty="easy">ğŸŸ¢ Easy / ×§×œ</button>
            <button class="difficulty-btn" data-difficulty="medium">ğŸŸ¡ Medium / ×‘×™× ×•× ×™</button>
            <button class="difficulty-btn" data-difficulty="hard">ğŸ”´ Hard / ×§×©×”</button>
        </div>

        <div class="display-area">
            <button id="speakerBtn" class="speaker-btn" onclick="handleSpeakerClick()">ğŸ”Š</button>
            <div id="displayText" class="display-text text-blue">×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!</div>
            <div id="spellingLetters" class="spelling-letters"></div>
        </div>

        <!-- Game Controls (for Spelling/Translation modes) -->
        <div id="gameControls" class="game-controls">
            <button class="game-btn repeat" onclick="repeatWord()">ğŸ” Repeat / ×—×–×•×¨</button>
            <button class="game-btn" onclick="nextWord()">â¡ï¸ Next / ×”×‘×</button>
        </div>

        <div class="button-area">
            <button id="mainButton" class="big-button button-ready">×œ×—×¥ ×œ×“×‘×¨!</button>
        </div>
    </div>

    <script>
        // ===========================================
        // PWA + INSTALL / FULLSCREEN
        // ===========================================

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('Service worker registered');
            }).catch(err => {
                console.log('Service worker registration skipped:', err.message);
            });
        }

        // Detect if running inside the Android APK
        const isAndroidApp = typeof AndroidBridge !== 'undefined' && AndroidBridge.isAndroidApp && AndroidBridge.isAndroidApp();

        // ===========================================
        // LETTER NAMES FOR SPELLING
        // ===========================================
        const HEBREW_LETTER_NAMES = {
            '×': '×Ö¸×œÖ¶×£', '×‘': '×‘ÖµÖ¼×™×ª', '×’': '×’Ö´Ö¼×™×Ö¶×œ', '×“': '×“Ö¸Ö¼×œÖ¶×ª', '×”': '×”Öµ×',
            '×•': '×•Ö¸×•', '×–': '×–Ö·×™Ö´×Ÿ', '×—': '×—Öµ×™×ª', '×˜': '×˜Öµ×™×ª', '×™': '×™×•Ö¹×“',
            '×›': '×›Ö¸Ö¼×£', '×š': '×›Ö¸Ö¼×£ ×¡×•Ö¹×¤Ö´×™×ª', '×œ': '×œÖ¸×Ö¶×“', '×': '×Öµ×', '×': '×Öµ× ×¡×•Ö¹×¤Ö´×™×ª',
            '× ': '× ×•Ö¼×Ÿ', '×Ÿ': '× ×•Ö¼×Ÿ ×¡×•Ö¹×¤Ö´×™×ª', '×¡': '×¡Ö¸×Ö¶×š', '×¢': '×¢Ö·×™Ö´×Ÿ', '×¤': '×¤ÖµÖ¼×',
            '×£': '×¤ÖµÖ¼× ×¡×•Ö¹×¤Ö´×™×ª', '×¦': '×¦Ö¸×“Ö´×™', '×¥': '×¦Ö¸×“Ö´×™ ×¡×•Ö¹×¤Ö´×™×ª', '×§': '×§×•Ö¹×£',
            '×¨': '×¨Öµ×™×©×', '×©': '×©Ö´××™×Ÿ', '×ª': '×ªÖ¸Ö¼×•'
        };

        // ===========================================
        // LANGUAGE CONFIGURATION
        // ===========================================
        const LANGUAGES = {
            hebrew: {
                code: 'he-IL',
                dir: 'rtl',
                text: {
                    SELECT_MODE: '×‘×—×¨ ××©×—×§',
                    FREE_SPEECH: '×“×™×‘×•×¨ ×—×•×¤×©×™',
                    SPELLING: '××™×•×ª',
                    TRANSLATION: '×ª×¨×’×•×',
                    ECHO: '×—×™×§×•×™',
                    TRANSLATING: '××ª×¨×’×...',
                    TRANSLATE_TO: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª ×œ×ª×¨×’×•× ×œ×× ×’×œ×™×ª',
                    TRANSLATION_ERROR: '×©×’×™××ª ×ª×¨×’×•×',
                    BACK: 'â† ×—×–×¨×”',
                    TAP_TO_SPEAK: '×œ×—×¥ ×œ×“×‘×¨!',
                    RECORDING: '××§×œ×™×˜... (×œ×—×¥ ×œ×¢×¦×™×¨×”)',
                    PROCESSING: '××¢×‘×“...',
                    LISTENING: '××§×©×™×‘...',
                    THINKING: '×—×•×©×‘...',
                    SAY_SOMETHING: '×××•×¨ ××©×”×• ×‘×¢×‘×¨×™×ª!',
                    NOT_UNDERSTOOD: '×œ× ×”×‘× ×ª×™',
                    NETWORK_ERROR: '×©×’×™××ª ×¨×©×ª',
                    NOT_SUPPORTED: '×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×§×•×œ',
                    NEED_PERMISSION: '× ×“×¨×©×ª ×”×¨×©××ª ××™×§×¨×•×¤×•×Ÿ'
                }
            },
            english: {
                code: 'en-US',
                dir: 'ltr',
                text: {
                    SELECT_MODE: 'Select Game',
                    FREE_SPEECH: 'Free Speech',
                    SPELLING: 'Spelling',
                    TRANSLATION: 'Translation',
                    ECHO: 'Echo Practice',
                    TRANSLATING: 'Translating...',
                    TRANSLATE_TO: 'Say something in English to translate to Hebrew',
                    TRANSLATION_ERROR: 'Translation error',
                    BACK: 'â† Back',
                    TAP_TO_SPEAK: 'Tap to Speak!',
                    RECORDING: 'Recording... (tap to stop)',
                    PROCESSING: 'Processing...',
                    LISTENING: 'Listening...',
                    THINKING: 'Thinking...',
                    SAY_SOMETHING: 'Say something in English!',
                    NOT_UNDERSTOOD: "Didn't understand",
                    NETWORK_ERROR: 'Network error',
                    NOT_SUPPORTED: 'Browser does not support speech recognition',
                    NEED_PERMISSION: 'Microphone permission required'
                }
            }
        };

        // ===========================================
        // STATE
        // ===========================================
        let currentLang = 'hebrew';
        let currentMode = null;
        let state = 'ready';
        let recognition = null;
        let recordingTimeout = null;
        let isRecognitionActive = false;
        let lastRecognizedText = '';
        let isSpeaking = false;

        // Spelling Bee Game State
        let wordsData = null;  // Loaded from words.json
        let spellingGame = {
            difficulty: null,
            currentWord: null,
            targetWord: null,
            userSpelling: [],
            wordList: []
        };

        // Echo Practice Game State
        let echoGame = {
            difficulty: null,
            currentWord: null,
            wordList: []
        };

        const MAX_RECORDING_TIME = 10000;

        // Load words.json on startup
        fetch('words.json')
            .then(response => response.json())
            .then(data => {
                wordsData = data;
                console.log('Words loaded:', wordsData);
            })
            .catch(error => console.error('Failed to load words.json:', error));

        function getEmoji(word) {
            if (!wordsData || !wordsData.emoji || !word) return '';
            return wordsData.emoji[word.trim()] || wordsData.emoji[word.trim().toLowerCase()] || '';
        }

        function emojiHtml(word) {
            const emoji = getEmoji(word);
            if (!emoji) return '';
            return `<span class="emoji-pop">${emoji}</span>`;
        }

        // ===========================================
        // ELEMENTS
        // ===========================================
        const modeScreen = document.getElementById('modeScreen');
        const gameScreen = document.getElementById('gameScreen');
        const modeTitle = document.getElementById('modeTitle');
        const freeSpeechLabel = document.getElementById('freeSpeechLabel');
        const spellingLabel = document.getElementById('spellingLabel');
        const translationLabel = document.getElementById('translationLabel');
        const echoLabel = document.getElementById('echoLabel');
        const displayText = document.getElementById('displayText');
        const mainButton = document.getElementById('mainButton');
        const errorBanner = document.getElementById('errorBanner');
        const btnHebrew = document.getElementById('btnHebrew');
        const btnEnglish = document.getElementById('btnEnglish');
        const speakerBtn = document.getElementById('speakerBtn');
        const backButton = document.querySelector('.back-button');
        const difficultySelector = document.getElementById('difficultySelector');
        const gameControls = document.getElementById('gameControls');
        const spellingLetters = document.getElementById('spellingLetters');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');

        // ===========================================
        // TEXT-TO-SPEECH
        // ===========================================
        const synth = window.speechSynthesis;

        // Use native Android TTS when running inside the APK
        const useNativeTts = isAndroidApp && typeof AndroidBridge.speak === 'function';

        // Estimate speech duration for native TTS (no onend callback available)
        function estimateSpeechDuration(text, rate = 0.8) {
            // ~100ms per character at normal rate, adjusted for speech rate
            return Math.max(800, (text.length * 100) / rate + 500);
        }

        function nativeSpeak(text, langCode, onComplete = null) {
            AndroidBridge.speak(text, langCode);
            if (onComplete) {
                setTimeout(onComplete, estimateSpeechDuration(text));
            }
        }

        function stopTts() {
            if (useNativeTts) {
                AndroidBridge.stopSpeaking();
            } else if (synth) {
                synth.cancel();
            }
        }

        function speakText(text = null, onComplete = null) {
            const textToSpeak = text || lastRecognizedText;
            if (!textToSpeak) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();
            setSpeaking(true);
            const langCode = LANGUAGES[currentLang].code;

            const done = () => {
                setSpeaking(false);
                if (onComplete) onComplete();
            };

            if (useNativeTts) {
                nativeSpeak(textToSpeak, langCode, done);
                return;
            }

            if (!synth) { done(); return; }

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = langCode;
            utterance.rate = 0.8;
            utterance.onend = done;
            utterance.onerror = done;
            synth.speak(utterance);
        }

        // Handle speaker button click - speaks in correct language based on mode
        function handleSpeakerClick() {
            if (!lastRecognizedText) return;

            if (currentMode === 'translation') {
                // In translation mode, lastRecognizedText is in the TARGET language
                const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';
                speakInLanguage(lastRecognizedText, targetLangCode);
            } else {
                speakText();
            }
        }

        // ===========================================
        // TRANSLATION API
        // ===========================================
        async function translateText(text, fromLang, toLang) {
            // Use MyMemory free translation API
            const langPair = `${fromLang}|${toLang}`;
            const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${langPair}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.responseStatus === 200 && data.responseData) {
                    return data.responseData.translatedText;
                } else {
                    console.error('Translation API error:', data);
                    return null;
                }
            } catch (error) {
                console.error('Translation fetch error:', error);
                return null;
            }
        }

        // Speak text in a specific language (not necessarily current language)
        function speakInLanguage(text, langCode, onComplete = null) {
            if (!text) {
                if (onComplete) onComplete();
                return;
            }

            stopTts();
            setSpeaking(true);

            const done = () => {
                setSpeaking(false);
                if (onComplete) onComplete();
            };

            if (useNativeTts) {
                nativeSpeak(text, langCode, done);
                return;
            }

            if (!synth) { done(); return; }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.8;
            utterance.onend = done;
            utterance.onerror = done;
            synth.speak(utterance);
        }

        // ===========================================
        // SPELLING BEE GAME FUNCTIONS
        // ===========================================
        function selectDifficulty(difficulty) {
            if (!wordsData) {
                showError('Word list not loaded yet');
                return;
            }

            if (currentMode === 'spelling') {
                // Spelling Bee mode
                spellingGame.difficulty = difficulty;
                spellingGame.wordList = wordsData.spelling[currentLang][difficulty] || [];
                
                if (spellingGame.wordList.length === 0) {
                    showError('No words available for this difficulty');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextWord();
            } else if (currentMode === 'echo') {
                // Echo Practice mode
                echoGame.difficulty = difficulty;
                const echoWords = wordsData.echo && wordsData.echo[currentLang];
                echoGame.wordList = (echoWords && echoWords[difficulty]) || [];
                
                console.log('Echo mode - difficulty:', difficulty, 'words:', echoGame.wordList);
                
                if (echoGame.wordList.length === 0) {
                    showError('No echo words for this level. Try another.');
                    return;
                }

                // Hide difficulty selector, show game controls
                difficultySelector.classList.remove('visible');
                gameControls.classList.add('visible');
                
                // Start first word
                nextEchoWord();
            }
        }

        // ECHO PRACTICE GAME FUNCTIONS
        // ===========================================
        function nextEchoWord() {
            if (!echoGame.wordList || echoGame.wordList.length === 0) {
                showError('No words available');
                return;
            }

            // Pick random word
            const randomIndex = Math.floor(Math.random() * echoGame.wordList.length);
            echoGame.currentWord = echoGame.wordList[randomIndex];
            
            // Update display - prompt user to listen
            displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘ ×œ××™×œ×”...' : 'Listen to the word...';
            displayText.className = 'display-text text-purple';
            
            // Show record button 
            mainButton.style.display = '';
            mainButton.textContent = 'ğŸ¤';
            mainButton.className = 'big-button button-ready';
            setState('ready');
            
            // Speak the word automatically, then update UI to prompt recording
            setTimeout(() => {
                speakText(echoGame.currentWord);
                // After word is spoken, show emoji + prompt user to repeat
                setTimeout(() => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Now you! Tap the microphone`;
                }, 1500);
            }, 500);
        }

        function handleEchoRecordingComplete(text) {
            if (!text || text.trim() === '') {
                showError(currentLang === 'hebrew' ? '×œ× ×”×‘× ×ª×™, × ×¡×” ×©×•×‘' : "I didn't understand, try again");
                setState('ready');
                return;
            }

            // Show what user said and encourage with emoji
            const echoEmoji = emojiHtml(echoGame.currentWord);
            displayText.innerHTML = currentLang === 'hebrew'
                ? `${echoEmoji}×××¨×ª: <b>${text}</b><br>××¢×•×œ×”! ğŸ‘<br><small>××™×œ×” ×”×‘××” ×‘×¢×•×“ ×©× ×™×™×”...</small>`
                : `${echoEmoji}You said: <b>${text}</b><br>Great! ğŸ‘<br><small>Next word coming...</small>`;
            displayText.className = 'display-text text-purple';

            // Play next word after delay
            setTimeout(() => {
                nextEchoWord();
            }, 2500);
        }

        function nextWord() {
            if (currentMode === 'echo') {
                // Echo mode - go to next word
                nextEchoWord();
            } else if (currentMode === 'spelling') {
                // Spelling mode - pick next spelling word
                if (!spellingGame.wordList || spellingGame.wordList.length === 0) {
                    showError('No words available');
                    return;
                }

                // Pick random word
                const randomIndex = Math.floor(Math.random() * spellingGame.wordList.length);
                spellingGame.targetWord = spellingGame.wordList[randomIndex];
                spellingGame.currentWord = spellingGame.targetWord;
                spellingGame.userSpelling = [];

                // Reset spelling letters display
                updateSpellingDisplay();

                // Speak the word
                displayText.textContent = 'ğŸ‘‚ Listen...';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = '';  // Show button for user to spell

                speakText(spellingGame.targetWord, () => {
                    // After speaking, show instruction
                    displayText.textContent = currentLang === 'hebrew' ? '×¢×›×©×™×• ××ª×”! ××•×ª ××—×¨ ××•×ª' : 'Your turn! Spell it letter by letter';
                    displayText.className = 'display-text text-green';
                    setState('ready');
                });
            }
        }

        function repeatWord() {
            if (currentMode === 'echo') {
                // Echo mode - repeat the current word
                if (!echoGame.currentWord) return;

                displayText.textContent = currentLang === 'hebrew' ? '×”×§×©×‘ ×œ××™×œ×”...' : 'Listen to the word...';
                displayText.className = 'display-text text-purple';

                speakText(echoGame.currentWord, () => {
                    const wordEmoji = emojiHtml(echoGame.currentWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${wordEmoji}×¢×›×©×™×• ××ª×”! ×”×§×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ`
                        : `${wordEmoji}Now you! Tap the microphone`;
                });
            } else if (currentMode === 'spelling') {
                // Spelling mode - repeat the target word
                if (!spellingGame.targetWord) return;

                displayText.textContent = 'ğŸ‘‚ Listen...';
                displayText.className = 'display-text text-blue';

                speakText(spellingGame.targetWord, () => {
                    displayText.textContent = currentLang === 'hebrew' ? '×¢×›×©×™×• ××ª×”! ××•×ª ××—×¨ ××•×ª' : 'Your turn! Spell it letter by letter';
                    displayText.className = 'display-text text-green';
                });
            }
        }

        function updateSpellingDisplay() {
            if (!spellingGame.targetWord) {
                spellingLetters.innerHTML = '';
                return;
            }

            const letters = [...spellingGame.targetWord];
            spellingLetters.innerHTML = letters.map((letter, index) => {
                let className = 'spelling-letter';
                let content = '_';
                
                if (spellingGame.userSpelling[index]) {
                    content = spellingGame.userSpelling[index].char;
                    className += spellingGame.userSpelling[index].correct ? ' correct' : ' incorrect';
                }
                
                return `<div class="${className}">${content}</div>`;
            }).join('');
        }

        function checkSpelling(spokenText) {
            if (!spellingGame.targetWord) return;
            
            // Normalize the spoken text
            const normalized = spokenText.trim().toLowerCase();
            const targetLetters = [...spellingGame.targetWord.toLowerCase()];
            
            // Track which positions are already filled
            const filledPositions = new Set(
                Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k])
                    .map(k => parseInt(k))
            );
            
            // Check if user spoke a single letter
            let matchedLetterIndex = -1;
            
            // For Hebrew, check against letter names
            if (currentLang === 'hebrew') {
                for (const [letter, name] of Object.entries(HEBREW_LETTER_NAMES)) {
                    if (normalized.includes(name.toLowerCase()) || normalized.includes(letter)) {
                        // Find first unfilled position for this letter
                        for (let i = 0; i < targetLetters.length; i++) {
                            if (targetLetters[i] === letter.toLowerCase() && !filledPositions.has(i)) {
                                matchedLetterIndex = i;
                                spellingGame.userSpelling[i] = { char: letter, correct: true };
                                break;
                            }
                        }
                        break;
                    }
                }
            } else {
                // For English, check if it's a single letter
                if (normalized.length === 1 && /[a-z]/.test(normalized)) {
                    for (let i = 0; i < targetLetters.length; i++) {
                        if (targetLetters[i] === normalized && !filledPositions.has(i)) {
                            matchedLetterIndex = i;
                            spellingGame.userSpelling[i] = { char: normalized, correct: true };
                            break;
                        }
                    }
                }
            }
            
            if (matchedLetterIndex >= 0) {
                // Correct letter!
                updateSpellingDisplay();
                
                // Check if word is complete (count filled positions)
                const filledCount = Object.keys(spellingGame.userSpelling)
                    .filter(k => spellingGame.userSpelling[k] && spellingGame.userSpelling[k].correct)
                    .length;
                
                if (filledCount === targetLetters.length) {
                    // Word completed successfully! Show emoji celebration
                    const spellingEmoji = emojiHtml(spellingGame.targetWord);
                    displayText.innerHTML = currentLang === 'hebrew'
                        ? `${spellingEmoji}ğŸ‰ ××¦×•×™×Ÿ! ××™×œ×” × ×›×•× ×”!`
                        : `${spellingEmoji}ğŸ‰ Excellent! Correct!`;
                    displayText.className = 'display-text text-green';
                    speakText(currentLang === 'hebrew' ? '××¦×•×™×Ÿ' : 'Excellent');
                    
                    // Auto next word after delay
                    setTimeout(nextWord, 2000);
                } else {
                    // Continue spelling
                    displayText.textContent = currentLang === 'hebrew' ? '× ×›×•×Ÿ! âœ“ ×”××©×š...' : 'Correct! âœ“ Continue...';
                    displayText.className = 'display-text text-green';
                }
            } else {
                // Incorrect or unrecognized
                displayText.textContent = currentLang === 'hebrew' ? 'âŒ × ×¡×” ×©×•×‘' : 'âŒ Try again';
                displayText.className = 'display-text text-red';
            }
        }

        // ===========================================
        // LANGUAGE FUNCTIONS
        // ===========================================
        function getText(key) {
            return LANGUAGES[currentLang].text[key];
        }

        function setLanguage(lang) {
            currentLang = lang;
            const langConfig = LANGUAGES[lang];

            // Update document direction
            document.documentElement.lang = lang === 'hebrew' ? 'he' : 'en';
            document.documentElement.dir = langConfig.dir;

            // Update toggle buttons
            btnHebrew.classList.toggle('active', lang === 'hebrew');
            btnEnglish.classList.toggle('active', lang === 'english');

            // Update UI text
            updateUIText();

            // Reinitialize speech recognition with new language
            initSpeechRecognition();

            // Reset state
            if (state !== 'ready') {
                stopRecording();
            }
            setState('ready');
        }

        function updateUIText() {
            // Mode screen
            modeTitle.textContent = getText('SELECT_MODE');
            freeSpeechLabel.textContent = getText('FREE_SPEECH');
            spellingLabel.textContent = getText('SPELLING');
            translationLabel.textContent = getText('TRANSLATION');
            echoLabel.textContent = getText('ECHO');

            // Game screen
            backButton.textContent = getText('BACK');

            // Update based on current state
            if (state === 'ready') {
                if (currentMode === 'translation') {
                    displayText.textContent = getText('TRANSLATE_TO');
                } else {
                    displayText.textContent = getText('SAY_SOMETHING');
                }
                mainButton.textContent = getText('TAP_TO_SPEAK');
            }
        }

        // ===========================================
        // MODE NAVIGATION
        // ===========================================
        function startMode(mode) {
            currentMode = mode;
            modeScreen.classList.add('hidden');
            gameScreen.classList.add('active');
            
            // Reset UI elements
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            
            // Mode-specific initialization
            if (mode === 'spelling') {
                // Show difficulty selector for spelling mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-blue';
                mainButton.style.display = 'none';
                
                // Reset spelling game state
                spellingGame.difficulty = null;
                spellingGame.currentWord = null;
                spellingGame.targetWord = null;
                spellingGame.userSpelling = [];
                spellingGame.wordList = [];
            } else if (mode === 'echo') {
                // Show difficulty selector for echo mode
                difficultySelector.classList.add('visible');
                displayText.textContent = currentLang === 'hebrew' ? '×‘×—×¨ ×¨××ª ×§×•×©×™' : 'Select Difficulty';
                displayText.className = 'display-text text-purple';
                mainButton.style.display = 'none';
                
                // Reset echo game state
                echoGame.difficulty = null;
                echoGame.currentWord = null;
                echoGame.wordList = [];
                
                // Check if wordsData is loaded
                if (!wordsData || !wordsData.echo) {
                    displayText.textContent = currentLang === 'hebrew' ? '×˜×•×¢×Ÿ ××™×œ×™×...' : 'Loading words...';
                }
            } else {
                // For free-speech and translation modes, show main button
                mainButton.style.display = '';
                setState('ready');
            }
        }

        function goBack() {
            if (isRecognitionActive) {
                stopRecording();
            }
            stopTts();

            currentMode = null;
            lastRecognizedText = '';
            speakerBtn.classList.remove('visible');
            difficultySelector.classList.remove('visible');
            gameControls.classList.remove('visible');
            spellingLetters.innerHTML = '';
            mainButton.style.display = '';
            gameScreen.classList.remove('active');
            modeScreen.classList.remove('hidden');
        }

        // ===========================================
        // SPEECH RECOGNITION
        // ===========================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        function initSpeechRecognition() {
            if (!SpeechRecognition) {
                showError(getText('NOT_SUPPORTED') + ' - Use Chrome');
                return;
            }

            // Stop existing recognition
            if (recognition) {
                try {
                    recognition.abort();
                } catch (e) {}
            }

            recognition = new SpeechRecognition();
            recognition.lang = LANGUAGES[currentLang].code;
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log('Recognition started');
                isRecognitionActive = true;
                setState('recording');

                recordingTimeout = setTimeout(() => {
                    console.log('Auto-stopping after timeout');
                    stopRecording();
                }, MAX_RECORDING_TIME);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (finalTranscript) {
                    console.log('Final:', finalTranscript);
                    clearRecordingTimeout();
                    showResult(finalTranscript);
                } else if (interimTranscript) {
                    console.log('Interim:', interimTranscript);
                    displayText.textContent = interimTranscript;
                    displayText.className = 'display-text text-black';
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                clearRecordingTimeout();
                isRecognitionActive = false;

                switch (event.error) {
                    case 'not-allowed':
                        showError(getText('NEED_PERMISSION'));
                        showResult(getText('NEED_PERMISSION'));
                        break;
                    case 'network':
                        showResult(getText('NETWORK_ERROR'));
                        break;
                    case 'no-speech':
                        showResult(getText('NOT_UNDERSTOOD'));
                        break;
                    case 'aborted':
                        setState('ready');
                        break;
                    default:
                        showResult(getText('NOT_UNDERSTOOD'));
                }
            };

            recognition.onend = () => {
                console.log('Recognition ended');
                clearRecordingTimeout();
                isRecognitionActive = false;

                if (state === 'recording') {
                    showResult(getText('NOT_UNDERSTOOD'));
                }
            };
        }

        function clearRecordingTimeout() {
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
        }

        // ===========================================
        // STATE MANAGEMENT
        // ===========================================
        function setState(newState) {
            state = newState;

            switch (state) {
                case 'ready':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    // Show appropriate prompt based on mode
                    if (currentMode === 'translation') {
                        displayText.textContent = getText('TRANSLATE_TO');
                    } else {
                        displayText.textContent = getText('SAY_SOMETHING');
                    }
                    displayText.className = 'display-text text-blue';
                    break;

                case 'recording':
                    mainButton.textContent = getText('RECORDING');
                    mainButton.className = 'big-button button-recording';
                    displayText.textContent = getText('LISTENING');
                    displayText.className = 'display-text text-red';
                    speakerBtn.classList.remove('visible');
                    break;

                case 'processing':
                    mainButton.textContent = getText('PROCESSING');
                    mainButton.className = 'big-button button-processing';
                    displayText.textContent = getText('THINKING');
                    displayText.className = 'display-text text-yellow';
                    break;

                case 'showing':
                    mainButton.textContent = getText('TAP_TO_SPEAK');
                    mainButton.className = 'big-button button-ready';
                    break;
            }
        }

        function showResult(text) {
            const isError = text === getText('NOT_UNDERSTOOD') ||
                           text === getText('NETWORK_ERROR') ||
                           text === getText('NEED_PERMISSION');

            // Handle translation mode separately
            if (currentMode === 'translation' && !isError) {
                handleTranslationResult(text);
                return;
            }

            // Handle spelling mode game separately
            if (currentMode === 'spelling' && !isError && spellingGame.targetWord) {
                checkSpelling(text);
                // Stay in ready state to continue spelling
                setState('ready');
                return;
            }

            // Handle echo mode - encourage and play next word
            if (currentMode === 'echo' && !isError) {
                handleEchoRecordingComplete(text);
                return;
            }

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';
            const resultEmoji = isError ? '' : emojiHtml(text);
            displayText.innerHTML = resultEmoji ? `${resultEmoji}${text}` : text;
            displayText.className = 'display-text text-black';

            // Store for TTS and show speaker button
            if (!isError) {
                lastRecognizedText = text;
                speakerBtn.classList.add('visible');
            } else {
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');
            }
        }

        async function handleTranslationResult(spokenText) {
            // Show translating state
            state = 'processing';
            mainButton.textContent = getText('PROCESSING');
            mainButton.className = 'big-button button-processing';
            displayText.textContent = getText('TRANSLATING');
            displayText.className = 'display-text text-yellow';

            // Determine source and target languages
            const fromLang = currentLang === 'hebrew' ? 'he' : 'en';
            const toLang = currentLang === 'hebrew' ? 'en' : 'he';
            const targetLangCode = currentLang === 'hebrew' ? 'en-US' : 'he-IL';

            // Translate
            const translation = await translateText(spokenText, fromLang, toLang);

            state = 'showing';
            mainButton.textContent = getText('TAP_TO_SPEAK');
            mainButton.className = 'big-button button-ready';

            if (translation) {
                // Show both original and translation with emoji
                const transEmoji = emojiHtml(spokenText) || emojiHtml(translation);
                displayText.innerHTML = `${transEmoji}<div style="font-size: 0.5em; color: #888; margin-bottom: 10px;">${spokenText}</div>${translation}`;
                displayText.className = 'display-text text-black';
                lastRecognizedText = translation;
                speakerBtn.classList.add('visible');

                // Speak the translation in target language
                setTimeout(() => {
                    speakInLanguage(translation, targetLangCode);
                }, 300);
            } else {
                displayText.textContent = getText('TRANSLATION_ERROR');
                displayText.className = 'display-text text-red';
                lastRecognizedText = '';
                speakerBtn.classList.remove('visible');
            }
        }

        function showError(message) {
            errorBanner.textContent = message;
            errorBanner.classList.add('show');
            setTimeout(() => {
                errorBanner.classList.remove('show');
            }, 5000);
        }

        // ===========================================
        // RECORDING CONTROL
        // ===========================================
        function startRecording() {
            if (!recognition) {
                showError(getText('NOT_SUPPORTED'));
                return;
            }

            if (isRecognitionActive) {
                console.log('Recognition already active, ignoring start');
                return;
            }

            try {
                recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                isRecognitionActive = false;

                if (e.message && e.message.includes('already')) {
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e2) {
                            showError('Error: ' + e2.message);
                        }
                    }, 200);
                } else {
                    showError('Error: ' + e.message);
                }
            }
        }

        function stopRecording() {
            if (!recognition || !isRecognitionActive) {
                return;
            }

            console.log('Stopping recording');
            clearRecordingTimeout();

            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
        }

        let lastButtonPress = 0;
        function handleButtonClick() {
            if (isSpeaking) return;

            const now = Date.now();
            if (now - lastButtonPress < 400) return;
            lastButtonPress = now;

            if (state === 'recording') {
                stopRecording();
            } else if (state === 'ready' || state === 'showing') {
                startRecording();
            }
        }

        // ===========================================
        // TTS UI LOCK
        // ===========================================
        function setSpeaking(speaking) {
            isSpeaking = speaking;
            if (speaking) {
                mainButton.classList.add('button-speaking');
                mainButton.disabled = true;
            } else {
                mainButton.classList.remove('button-speaking');
                mainButton.disabled = false;
            }
        }

        // ===========================================
        // EVENT LISTENERS
        // ===========================================
        // Single pointerup listener prevents double-fire from click+touchend
        mainButton.addEventListener('pointerup', (e) => {
            e.preventDefault();
            handleButtonClick();
        });

        // Add event listeners for difficulty buttons
        difficultyBtns.forEach((btn) => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const difficulty = e.currentTarget.dataset.difficulty;
                selectDifficulty(difficulty);
            });
        });
        // ===========================================
        // INITIALIZATION
        // ===========================================
        function init() {
            // Request microphone permission
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                        console.log('Microphone permission granted');
                    })
                    .catch(err => {
                        console.log('Microphone permission not yet granted:', err);
                    });
            }

            // Initialize with Hebrew
            setLanguage('hebrew');
            console.log('Hebrew Voice App loaded');
        }

        init();
    </script>
</body>
</html>
